Коротко про timeout и idle_timeout:
Сервера обычно оптимизированы таким образом, что если нам от одного клиента приходят запросы за какое-то короткое время, то мы используем одно соединение. Нет смысла открывать и закрывать соединение на каждый запрос. Но если клиент нам долго не отвечает или не запрашивает информацию, то такое соединение необходимо обрывать.

Если мы говорим про Го, то основная структура это http.Server. Основные параметры:

- ReadHeaderTimeout - время, отводимое на чтение заголовков запроса
- ReadTimeout - максимальная продолжительность чтения полного запроса, включая тело
- WriteTimeout - максимальное время ожидания до окончания записи ответа
- IdleTimeout - максимальное время ожидания следующего запроса, используется keep-alive

Коротка процесс можно описать так:

1. Подключение установлено
   |--- ReadHeaderTimeout (если установлен) ---|
2. Заголовки запроса получены
   |--- ReadTimeout (если установлен) ---|
3. Тело запроса получено, начинается обработка запроса
4. Обработка завершена, сервер начинает отправлять ответ
   |--- WriteTimeout (если установлен) ---|
5. Ответ полностью отправлен клиенту
   |--- IdleTimeout (если установлен и соединение остается открытым) ---|
6. Если не было другого запроса в течение IdleTimeout, соединение закрывается
7. Если новый запрос получен до IdleTimeout, процесс начинается сначала с шага 2

Зачем нужно столько таймаутов?

- Борьба с Slowloris атаками: это тип атаки, при которой злоумышленник устанавливает соединение с сервером и отправляет запрос нуу оооочень медленно. Это может приводить к исчерпанию ресурсов сервера и его последующему отказу. Установка ReadHeaderTimeout и ReadTimeout может помочь.
- Отправка больших данных: возможно, клиенты отправляют нам что-то очень большое, и мы не хотим чтобы это заняло слишком много времени. В этом случае помогает ReadTimeout
- Обратная ситуация - работа с ооочень медленными клиентами: Встречаются клиенты со слабым каналом, которые принимают наш ответ очень долго (например, некоторые устройства IoT или просто регионы со слабым интернет-покрытием). В этом случае, если не установить WriteTimeout, сервер может ждать бесконечно долго, пытаясь отправить ответ, что может привести к исчерпанию ресурсов.
- Ограничение использования ресурсов: При большом количестве запросов, особенно в микросервисных архитектурах, установка IdleTimeout помогает освободить ресурсы от долгоживущих соединений, которые больше не используются.

Рекомендации:
Рекомендуемые значения по типам приложений:

1. API сервисы (быстрые ответы):

- goReadTimeout: 10 \* time.Second
- WriteTimeout: 10 \* time.Second
- IdleTimeout: 30 \* time.Second

2. Файловые загрузки/выгрузки:

- goReadTimeout: 300 \* time.Second // 5 минут
- WriteTimeout: 300 \* time.Second
- IdleTimeout: 120 \* time.Second

3. Обычные веб-приложения:

- goReadTimeout: 15 \* time.Second
- WriteTimeout: 15 \* time.Second
- IdleTimeout: 60 \* time.Second

4. Load balancer/proxy:

- goReadTimeout: 5 \* time.Second
- WriteTimeout: 5 \* time.Second
- IdleTimeout: 30 \* time.Second
