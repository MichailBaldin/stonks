package main

// =======================
// Тренажёр: Maps (v1)
// =======================

// --- Блок A. Базовые операции ---

// 1. Объяви nil-map: var m map[string]int. Проверь m==nil и len(m).

// 2. Попробуй m["one"] = 1 на nil-map — ожидаем панику. Затем инициализируй m = make(map[string]int) и повтори запись.

// 3. Создай map литералом: m := map[string]int{"one":1, "two":2}. Выведи len и одно чтение m["one"].

// 4. Проверь идиому "comma ok": v, ok := m["three"]; выведи v и ok.

// 5. Удали ключ delete(m, "one"); проверь, что повторное delete не паникует.

// 6. Сделай make(map[string]int, 8) — подай hint на ёмкость; выведи len (cap недоступен).

// 7. Перебери map через for k, v := range m { ... }. Запусти несколько раз — зафиксируй, что порядок произволен.

// 8. Покажи, что m["x"]++ работает даже для отсутствующего ключа (нулевое значение).

// 9. Присвой по ключу новое значение поверх старого: m["two"]=10; проверь чтением.

// 10. Очисти map тремя способами: (а) m = make(map[string]int) (b) цикл delete (c) clear(m). Сравни эффекты для возможных копий ссылки.

// --- Блок B. Передача в функции ---

// 11. Напиши func Put(m map[string]int, k string, v int), вызови и проверь, что исходная map изменилась.

// 12. Покажи, что переназначение m = make(map[string]int) внутри функции НЕ влияет на исходную ссылку.

// 13. Напиши func ResetInPlace(m map[string]int) { clear(m) } и проверь, что исходная map стала пустой.

// 14. Реализуй Upsert: func Upsert(m map[string]int, k string, f func(int) int), которая читает текущее, применяет f и пишет обратно.

// 15. Сделай "удалить с возвратом": func DeleteGet(m map[string]int, k string) (int, bool) — вернуть старое значение и флаг существования.

// --- Блок C. Частые паттерны ---

// 16. Счётчик слов: по []string посчитай частоты map[string]int.
// 17. Множество через map[string]struct{}: добавь 3 элемента, проверь принадлежность и удаление.
// 18. Пересечение двух множеств (map[string]struct{}), верни новое множество.
// 19. Разность множеств A\B.
// 20. Дедупликация слайса строк с сохранением порядка через seen map[string]struct{}.

// --- Блок D. Итерация в определённом порядке ---

// 21. Собери срез ключей Keys([]) и отсортируй sort.Strings; пройдись по m в порядке ключей.
// 22. Отсортируй пары по значению: сформируй []struct{k string; v int}, отсортируй по v по убыванию.
// 23. Сформируй топ-N по значению из map[string]int.
// 24. Сгруппируй пользователей по городу: из []User -> map[string][]User.
// 25. Построй индекс по id: []User -> map[int]User (перезапись при дубликате id).

// --- Блок E. Вложенные структуры ---

// 26. map[string][]int: добавь элемент в срез по ключу, предварительно инициализировав пустым срезом при отсутствии ключа.
// 27. map[string]map[string]int: инкремент m[a][b] с безопасной инициализацией внутренней map.
// 28. "Инверсия" map[string]int -> map[int][]string (значение -> список ключей).
// 29. Глубокая копия map[string][]int (новая map и новые срезы).
// 30. Объединение двух map[string]int: merge с политикой "вторая перекрывает первую".

// --- Блок F. Ключи и сравнимость (comparable) ---

// 31. Используй массив как ключ: map[[2]int]int — посчитай счётчики для пар координат.
// 32. Используй struct как ключ (только сравнимые поля): type Key struct{ A int; B string }.
// 33. Попробуй (закомментируй) сделать ключом []int или map[string]int — зафиксируй ошибку компиляции и объясни почему.
// 34. Сравни поведение ключей-указателей: map[*User]int — две разные переменные с одинаковыми полями считаются разными ключами.
// 35. Покажи разницу между ключом struct и *struct в уникальности записей.

// --- Блок G. JSON и сериализация ---

// 36. Сериализуй map[string]int в JSON и обратно (encoding/json). Порядок полей в JSON не гарантируется.
// 37. Сериализуй map[int]string — зафиксируй, что ключи в JSON превращаются в строки.
// 38. Сериализуй map[string]any со значениями разных типов и прочитай обратно в map[string]any.
// 39. Преобразуй []Pair{Key,Val} в map и обратно (для стабильного порядка при выводе).
// 40. Сконструируй "плоский" JSON индекс: из []User -> map[string]int{"name":id}.

// --- Блок H. Безопасные модификации при обходе ---

// 41. Удаляй ключи во время range: for k := range m { if условие { delete(m,k) } } — покажи, что это корректно.
// 42. Построй фильтрованную map из исходной без модификации оригинала.
// 43. Разнеси объекты на две map по предикату (partition).
// 44. Реализуй CloneShallow map[string]int (поверхностная копия через make+range).

// --- Блок I. Производительность/границы API ---

// 45. Покажи, что cap(map) недоступен; инициализация make(map[K]V, n) — лишь hint для уменьшения перераспределений.
// 46. Инициализируй большую map, затем занули её clear(m); сравни с m = nil и с m = make(...), как ведёт себя len и запись/чтение.
// 47. Проверь, что чтение отсутствующего ключа даёт zero value типа значения (int=0, string="").
// 48. Реализуй EqualShallow(a,b map[string]int) bool без reflect: сравни len и значения по ключам.
// 49. Реализуй Diff(a,b map[string]int): какие ключи добавлены, удалены, изменены.
// 50. Напиши SafeGet(m map[string]int, k string, def int) int — вернуть значение или def, не меняя map.
