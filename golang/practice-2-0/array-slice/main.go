package main

import (
	"fmt"
)

// ============================
// Тренажёр: Массивы и Слайсы v2
// ============================

// --- Блок А. Массивы (значимые отличия от слайсов) ---

// 1. Объяви массив из 3 int, проинициализируй литералом и выведи элементы.

// 2. Создай массив с длиной, определяемой компилятором: [...]int{1,2,3}.

// 3. Передай массив в функцию по значению и измени внутри — проверь, что снаружи не изменился.

// 4. Передай *на массив* указатель в функцию и измени — проверь, что изменился.

// 5. Сконвертируй массив в слайс через arr[:] и измени через слайс — проверь, что меняется массив.

// 6. Сделай копию массива простым присваиванием b := a; измени b и покажи независимость.

// 7. Сравни два массива оператором == (как работает сравнение?).

// 8. Создай многомерный массив [2][3]int и присвой элемент [1][2] = 99.

// 9. Создай слайс фиксированных пар: var pairs [][2]int; добавь две пары и выведи.

// 10. Напиши функцию, принимающую [3]int, которая возвращает сумму элементов (проверка сигнатур).

// --- Блок B. Слайсы: создание, длина/ёмкость, базовые операции ---

// 11. Создай nil-слайс: var s []int. Проверь: s==nil, len, cap.

// 12. Создай пустой литерал: s := []int{}. Сравни с nil-слайсом по len, cap и (s==nil).

// 13. Сделай s := make([]int, 3, 5), заполни 1..3, выведи len и cap.

// 14. Добавь в s три элемента подряд и после каждого append печатай len/cap.

// 15. Срежь массив arr := [5]int{10,20,30,40,50} -> s := arr[1:3]; выведи s.

// 16. Используй полное выражение среза: s := arr[1:3:3]; выведи cap(s) и объясни, почему так.

// 17. Обнули длину без выделения: s = s[:0]; добавь два элемента, выведи len/cap.

// 18. Раскрой слайс до полной ёмкости: s = s[:cap(s)]; выведи len/cap.

// 19. Возьми адрес первого элемента до/после серии append (&s[0]) — зафиксируй, менялся ли указатель (реаллокация).

// 20. Создай dst меньшего размера, чем src, сделай n := copy(dst, src); выведи n, dst.
func main() {
	src := []int{1, 2, 3, 4, 5}
	dst := make([]int, 3)
	fmt.Println(dst)
	n := copy(dst, src)
	fmt.Printf("n: %d, dst: %v\n", n, dst)
}

// --- Блок C. Мутации: удаление/вставка/клон/фильтрация ---

// 21. Удали элемент по индексу i с сохранением порядка через copy().
// 22. Удали элемент по индексу i БЕЗ сохранения порядка (swap с последним, усечь).
// 23. Вставь элемент x на позицию i (используй append и сдвиг правой части).
// 24. Клонируй слайс: clone := append([]T(nil), s...); измени clone и покажи независимость.
// 25. Разверни слайс in-place (две переменные-индекса, обмен концов).
// 26. Отфильтруй только чётные, используя приём "filter in place": dst := s[:0].
// 27. Расширь слайс на 3 позиции: s = append(s, make([]int, 3)...); заполни новые элементы.
// 28. Объедини два слайса: s = append(s, t...).

// --- Блок D. Поведение в функциях (важно понимать семантику) ---

// 29. Напиши функцию DoubleInPlace([]int), умножающую каждый элемент — проверь, что исходный слайс изменился.
// 30. Напиши функцию AppendAndReturn([]int, vals ...int) []int; вызови без присваивания и с присваиванием — сравни результат.
// 31. Покажи кейс, когда append внутри функции НЕ влияет на исходный слайс, если результат не присваивать снаружи.
// 32. Передай в функцию подслайс, у которого cap ограничен через полное выражение среза, и внутри сделай append — проверь, что не затронут соседний участок.
// 33. (Для понимания) Сделай функцию AppendPtr(*[]int, v int), которая добавляет элемент без возврата — вызови и проверь результат.
// 34. Реализуй Sum([]int) int — сумма элементов.
// 35. Реализуй IndexOf([]int, x int) int — индекс первого вхождения или -1.
// 36. Реализуй Chunk([]int, size int) [][]int — разбиение на чанки фиксированного размера.

// --- Блок E. Двумерные слайсы (матрицы) ---

// 37. Создай матрицу 2×3 как [][]int через make; заполни по формуле m[i][j] = i*10 + j.
// 38. Покажи ошибку aliasing: создай две строки матрицы, указывающие на один и тот же внутренний слайс; измени один элемент и зафиксируй эффект; исправь, создав независимые строки.
// 39. Напиши функцию Transpose([][]int) [][]int для квадратной матрицы 2×2 (минимальный случай).
// 40. Сгладь [][]int в []int (flatten). Сначала посчитай общий размер, затем сделай один выделенный make и один проход с copy.

// --- Блок F. Строки, байты, руны (как типичные слайсы) ---

// 41. Преобразуй строку в []byte, измени один байт, собери обратно строку.
// 42. Разверни строку корректно по Unicode: string -> []rune -> reverse -> string.
// 43. Собери строку из []rune вручную (создай []rune, присвой символы, сконвертируй).
// 44. Создай буфер []byte с предвыделением cap=64, поappend’и несколько байтов, выведи len/cap.
// 45. Сконвертируй []int в строку с числами через промежуточный []byte (fmt.Append* или strconv + append к []byte).

// --- Блок G. Память, границы, подводные камни ---

// 46. Покажи "удержание памяти": сделай большой слайс big, затем small := big[:3]; освободи ссылку на big, но измерь cap/адрес small; затем почини копированием small = append([]int(nil), small...).
// 47. Смести поддиапазон влево: copy(s[i:], s[j:]); затем усечь длину — проверь корректность.
// 48. Сравни рост cap при многократном append для маленького и большого начального cap; зафиксируй последовательность ростов.
// 49. Сравни поведение var s []int и s := make([]int, 0) при первом append (nil-слайс тоже корректно аппендится).
// 50. Добавь безопасный доступ к элементу по индексу: если i вне диапазона — не паникуй, верни "не найдено".
