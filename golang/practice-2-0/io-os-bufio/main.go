package main

// =====================================
// Тренажёр: io, os, bufio, файлы (v1)
// =====================================
// Делай по 5–10 за подход. Везде аккуратно обрабатывай ошибки и закрывай файлы через defer.

// --- Блок A. Пути и наличие файлов ---

// 1. Выведи текущую рабочую директорию через os.Getwd().
// 2. Построй путь к файлу "data/input.txt" через filepath.Join(dir, "data", "input.txt").
// 3. Проверь существование файла: os.Stat + errors.Is(err, fs.ErrNotExist).
// 4. Создай папку "out/logs" через os.MkdirAll с правами 0755.
// 5. Получи абсолютный путь к файлу относительно cwd: filepath.Abs("data/input.txt").

// --- Блок B. Открытие/чтение/запись (малые файлы) ---

// 6. Прочитай небольшой файл целиком os.ReadFile, выведи len(bytes).
// 7. Запиши []byte в файл через os.WriteFile с правами 0644.
// 8. Создай пустой файл через os.Create и запиши строку через WriteString.
// 9. Открой существующий файл read-only: f, _ := os.Open(...); прочитай первые 16 байт в буфер []byte.
// 10. Прочитай файл в цикле фиксированным буфером 4KB до io.EOF; посчитай суммарные байты.

// --- Блок C. os.OpenFile и режимы/флаги ---

// 11. Открой файл для перезаписи: os.OpenFile(..., os.O_CREATE|os.O_WRONLY|os.O_TRUNC, 0644) и запиши текст.
// 12. Открой файл в режиме дозаписи: os.O_APPEND и добавь две строки подряд.
// 13. Вызови f.Sync() после записи и объясни, зачем это может быть нужно.
// 14. Обрежь файл до 10 байт через f.Truncate(10).
// 15. Проверь права: после создания 0600 прочитай mode из FileInfo.Mode() и выведи.

// --- Блок D. bufio.Reader (построчно/побайтно) ---

// 16. Оберни *os.File в bufio.NewReader; считай одну строку через ReadString('\n').
// 17. Считай файл построчно в цикле через ReadString('\n'), корректно обработай последний фрагмент без '\n'.
// 18. Считай байт через ReadByte, затем верни его назад с UnreadByte и снова прочитай.
// 19. Прочитай руну через ReadRune и выведи её и размер в байтах.
// 20. Используй Peek(8), чтобы заглянуть в следующие 8 байт, не продвигая позицию.

// --- Блок E. bufio.Writer (буферизированная запись) ---

// 21. Оберни *os.File в bufio.NewWriter; WriteString несколько раз и Flush() в конце.
// 22. Выведи Buffered() и Available() до и после WriteString, затем после Flush().
// 23. Создай bufio.NewWriterSize с небольшим буфером (например, 8 байт) и покажи, что Flush обязателен.
// 24. Используй w.Reset(другойФайл) для повторного использования буфера.
// 25. Сочетай bufio.Writer + os.O_APPEND: дозапиши три строки одним Flush.

// --- Блок F. bufio.Scanner (токенизация) ---

// 26. Считай файл построчно через bufio.NewScanner(file); выведи кол-во строк.
// 27. Установи Split(bufio.ScanWords) и посчитай слова (map[string]int частоты).
// 28. Увеличь буфер сканера scanner.Buffer(make([]byte, 0, 1024), 1024*1024) для длинных строк; проверь scanner.Err().
// 29. Реализуй сканирование по разделителю ';' через SplitFunc.
// 30. Считай stdin (os.Stdin) сканером построчно и эхо-выводи на stdout.

// --- Блок G. Потоки и утилиты io ---

// 31. Скопируй содержимое файла на stdout через io.Copy(os.Stdout, file).
// 32. Скопируй только первые N байт файла через io.CopyN(dst, src, N).
// 33. Используй io.LimitReader(src, N) и скопируй в файл; сравни с CopyN.
// 34. Оберни src в io.TeeReader и параллельно считай количество байт (счётчик); выведи итог.
// 35. Направь вывод одновременно в файл и stdout через io.MultiWriter.
// 36. Прочитай весь Reader в память через io.ReadAll и выведи длину (замечание: годится только для малых файлов).
// 37. Накопи данные в bytes.Buffer (он — Writer); затем единожды запиши Buffer.Bytes() в файл.
// 38. Используй io.NopCloser(bytes.NewReader(...)) там, где требуется ReadCloser.

// --- Блок H. Директории и обход ---

// 39. Перечисли файлы каталога через os.ReadDir("data"); выведи имена в срез []string.
// 40. Получи детальную информацию по каждому элементу через DirEntry.Info() (размер, режим).
// 41. Пройди дерево каталогов через filepath.WalkDir; собери map[string]int64 путей к файлам → размер.
// 42. Создай временную директорию через os.MkdirTemp и временный файл через os.CreateTemp; запиши и удали.
// 43. Переименуй файл os.Rename и затем удали os.Remove.

// --- Блок I. Форматы данных (поверх io) ---

// 44. Прочитай CSV (encoding/csv) из файла и собери [][]string; запиши другой CSV в новый файл.
// 45. Прочитай JSON из файла в структуру и запиши обратно с отступами; обработай случай пустого файла.
// 46. Запиши бинарно структуру {ID uint32; Value float64} через binary.Write (LittleEndian) и прочитай обратно binary.Read.
// 47. Преобразуй текстовый файл в верхний регистр построчно (Scanner) и запиши результат в новый файл буферизированно.

// --- Блок J. CLI-взаимодействие: stdin/stdout/args ---

// 48. Если аргумент командной строки не передан — читай из stdin и дублируй в stdout; иначе читай из указанного файла.
// 49. Реализуй "cp src dst": открой оба файла, скопируй через io.Copy, вызови Sync и проверь размер dst через Stat.
// 50. Реализуй "tail -n 10": выведи последние 10 строк файла, не загружая весь файл в память (подсказка: обратное чтение блоками).
