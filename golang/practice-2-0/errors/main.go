package main

// ======================================
// Тренажёр: Ошибки и errgroup (v1)
// ======================================
// Делай по 5–10 задач за подход. Везде печатай, что именно произошло, и ПОЧЕМУ.

// --- Блок A. База: создание и обёртка ошибок ---

// 1. Создай sentinel: var ErrNotFound = errors.New("not found"); верни её из функции и сравни напрямую и через errors.Is.
// 2. Сделай fmt.Errorf("wrap: %w", ErrNotFound); проверь, что errors.Is(err, ErrNotFound)==true.
// 3. Покажи, что в fmt.Errorf можно использовать только ОДИН %w (второй — компилятор ругнётся). Закомментируй пример с двумя %w.
// 4. Реализуй errors.Unwrap на своей обёртке и проверь, что Unwrap вернул внутреннюю ошибку.
// 5. Оберни несколько уровней подряд (3 раза) и проверь, что errors.Is доходит до исходной.

// --- Блок B. errors.Is / errors.As / Unwrap ---

// 6. Создай свой тип PathError{Path string; Err error} и метод Error() с контекстом. Используй errors.As, чтобы извлечь *PathError.
// 7. Подменяй Err внутри PathError на ErrNotFound и проверь через errors.Is(err, ErrNotFound).
// 8. Сделай цепочку: fmt.Errorf("outer: %w", &PathError{...}); через errors.As вытащи *PathError и распечатай Path.
// 9. Напиши Unwrap() на PathError, чтобы errors.Unwrap возвращал внутреннюю Err.
// 10. Сравни поведение errors.Is для двух разных sentinel с одинаковым текстом — покажи, что сравнивать надо значением, а не текстом.

// --- Блок C. Кастомные типы ошибок и политики ---

// 11. Опиши тип ValidationError{Field string; Msg string}. Проверяй поле и формируй человекочитаемое Error().
// 12. Сделай интерфейс Temporary{ Temporary() bool } и ошибку, которая его реализует; проверь os.IsTimeout/ошибка с Timeout() bool.
// 13. Реализуй AggregatedError с полем []error и методом Error(); сравни с errors.Join (см. ниже).
// 14. Сделай функцию Wrapf(err error, msg string) error, которая добавляет контекст без потери %w (через fmt.Errorf("%s: %w", ...)).
// 15. Добавь метод Is на своём типе, чтобы errors.Is работал по кастомному правилу (например, по коду).

// --- Блок D. Стандартные ошибки и идиомы ---

// 16. Поймай и различи io.EOF при чтении — это не всегда «ошибка»; покажи ветку с EOF отдельно.
// 17. Открой несуществующий файл; проверь errors.As(err, *os.PathError) и распечатай Op/Path.
// 18. Проверь os.IsNotExist(err) и os.IsPermission(err) для разных кейсов (несуществующий/без прав).
// 19. Создай контекст с таймаутом и дождись context.DeadlineExceeded; проверь errors.Is(err, context.DeadlineExceeded).
// 20. Отмени контекст вручную и проверь errors.Is(err, context.Canceled); отличи от DeadlineExceeded.

// --- Блок E. defer и обработка ошибок аккуратно ---

// 21. Функция с именованным результатом (err error). В defer, если err != nil — оберни его контекстом через %w.
// 22. В defer обработай ошибку Close(): если она не nil, присоедини к возвращаемой err через errors.Join.
// 23. Покажи баг shadowing: внутри функции объяви err := ... и потеряй внешнюю err; почини, убрав теневую переменную.
// 24. Реализуй try/finally-паттерн на defer: ресурсы закрываются всегда, ошибки аккумулируются.
// 25. Покажи, что отложенный panic в defer перехватывается recover и конвертируется в error (см. следующий блок).

// --- Блок F. panic / recover (минимум и безопасно) ---

// 26. Напиши функцию Safe(fn func()) (err error), которая делает recover в defer и возвращает error при панике.
// 27. Покажи, что паника с типом, НЕ являющимся error (например, string), всё равно превращается в error в Safe.
// 28. Объясни в комментарии разницу: когда использовать error vs panic (ошибка пользователя/окружения vs BUG).
// 29. Продемонстрируй, что паники обходят обычные ветки возврата, но defer всё равно выполнится.
// 30. Вызови Safe вокруг функции, которая разделит на ноль, и распечатай полученную error.

// --- Блок G. errors.Join (Go 1.20+) ---

// 31. Объедини две независимые ошибки через errors.Join(e1, e2); проверь, что errors.Is по каждой возвращает true.
// 32. Присоедини nil и non-nil в Join — проверь, что Join(nil, err) == err.
// 33. Создай Join из 3–4 ошибок и через errors.As попробуй вытащить один конкретный тип (например, *os.PathError).
// 34. Сравни AggregatedError из задания 13 и errors.Join по Error() и Is/As — зафиксируй поведение.
// 35. Применяй Join в defer для комбинирования основной ошибки и ошибки закрытия ресурса.

// --- Блок H. errgroup — базовые приёмы ---

// 36. Создай errgroup.WithContext(ctx) и 3 goroutine, одна возвращает ошибку; проверь, что Wait() вернёт её.
// 37. Внутри goroutine уважаем ctx.Done(): после первой ошибки остальные корректно завершаются раньше.
// 38. Собери частичные результаты в канал и закрой его после Wait; проверь, что данные успели прилететь до отмены.
// 39. Запусти 100 задач, из которых одна падает; измерь время — убедись, что отмена экономит время.
// 40. Покажи кейс гонки за переменную цикла при запуске goroutine; почини захватом локальной копии.

// --- Блок I. errgroup — расширенные приёмы и лимиты ---

// 41. Используй g.SetLimit(5) — обрабатывай 50 задач с параллелизмом 5; проверь, что общее время ~в 10 раз меньше единичной.
// 42. Совмещай errgroup с семафором (канал ёмкости K) — покажи отличие от SetLimit (ручной контроль критических секций).
// 43. Для каждой задачи возвращай детализированную ошибку (id, причина) и оборачивай через %w; снаружи делай errors.As для извлечения id.
// 44. Реализуй сбор «всех ошибок» самостоятельно: после Wait собери из канала []error и сделай errors.Join.
// 45. Построй пайплайн из трёх стадий, каждая — своя errgroup с общим контекстом; падение на стадии 2 отменяет 1 и 3.

// --- Блок J. Тесты и сравнение ошибок ---

// 46. Напиши табличный тест для функции, которая может вернуть ErrNotFound или ValidationError; проверяй через errors.Is/As, а не по тексту.
// 47. Покажи anti-pattern: сравнение err.Error()=="..."; замени на Is/As.
// 48. Покажи, что wrap-контекст в тексте ошибки НЕ должен участвовать в проверке (проверяем только корневую причину).
// 49. В тесте для errgroup проверь, что контекст отменяется (select на ctx.Done()) и Wait вернул ненулевую ошибку.
// 50. Проверь, что после errors.Join(err1, nil, err2) оба корня распознаются через Is, а nil игнорируется.

// --- Бонус-мини (по желанию) ---
// • API-дизайн: возвращай (T, error), не паникуй; ошибки — как значения; контекст первым аргументом; wrapping — у места потери контекста.
// • Логирование: логируй error и контекст (id, путь), но сравнение — только Is/As.
// • Документация: экспортные sentinel — комментируй; типовые ошибки — через types + As.
