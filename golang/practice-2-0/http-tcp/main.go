package main

// ======================================
// Тренажёр: HTTP & TCP — серверы и клиенты (v1)
// ======================================
// Правила:
// • Не забывай закрывать тела ответов/запросов (defer resp.Body.Close()).
// • Указывай таймауты у http.Server и http.Client. Уважай r.Context() и ctx.Done().
// • Закрывает TCP listener — владелец; завершай воркеров через контекст.
// • Логи и зависимости — через интерфейсы; без глобалов.

// -----------------------------
// Блок A. HTTP-сервер: база API
// -----------------------------

// 1. Подними минимальный http.Server на :8080, /health -> {"ok":true}.
// 2. Вынеси http.Server в переменную, задай ReadTimeout/WriteTimeout/IdleTimeout.
// 3. Сделай отдельный ServeMux; два маршрута: /ping и /time (RFC3339).
// 4. В хендлере выставь заголовок Content-Type: application/json перед WriteHeader.
// 5. Верни 400 при отсутствии обязательного query-параметра name.
// 6. Извлеки path-параметр вручную: /hello/{name} без сторонних роутеров.
// 7. Напиши helper JSON(w http.ResponseWriter, code int, v any) для ответов.
// 8. Сделай graceful shutdown: os.Signal -> ctx -> srv.Shutdown(ctx).
// 9. Проверь r.Context().Done(): если клиент закрыл соединение — прекрати работу.
// 10. Добавь middleware-логгер (интерфейс Logger) и обёртку ResponseWriter для кода ответа.

// ------------------------------------
// Блок B. HTTP: формы, файлы, потоки
// ------------------------------------

// 11. Обработай x-www-form-urlencoded POST: прочитай поле message.
// 12. Обработай multipart/form-data upload; сохрани файл в ./uploads.
// 13. Ограничь размер тела через http.MaxBytesReader (например, 2MB).
// 14. Отдавай статические файлы из ./public через http.FileServer.
// 15. Реализуй stream-ответ (text/event-stream): раз в секунду шли tick, до cancel.
// 16. Сформируй attachment-ответ (download) с корректным Content-Disposition.
// 17. Проксируй тело запроса в файл через io.Copy, считай SHA-256 на лету (io.TeeReader).
// 18. Установи ETag (хеш) и ответь 304 при If-None-Match совпадении.
// 19. Разбери multipart с несколькими файлами; верни список имён/размеров.
// 20. Безопасно обрежь лог-файл до N байт (os.OpenFile + Truncate) по POST.

// -----------------------------------
// Блок C. HTTP-клиент: база и таймауты
// -----------------------------------

// 21. Создай http.Client с Timeout=3s; GET на локальный /health.
// 22. Сконструируй запрос через http.NewRequestWithContext(ctx).
// 23. Прочитай JSON и распарсь в структуру Health{OK bool}.
// 24. Установи кастомный User-Agent в заголовок клиента.
// 25. Добавь базовую аутентификацию (SetBasicAuth) к запросу.
// 26. Проверь редиректы: Client.CheckRedirect ограничь до 3; обработай ошибку.
// 27. Скачай большой файл стримингом в os.Create без загрузки в память.
// 28. Сделай HEAD запрос и выведи Content-Length/Last-Modified.
// 29. Реализуй retry c экспоненциальным backoff на временные ошибки (Temporary/429/5xx).
// 30. Уважай ctx отмену: при cancel немедленно прекращай загрузку.

// -----------------------------------------------
// Блок D. HTTP-транспорт: пулы и низкоуровневые
// -----------------------------------------------

// 31. Создай http.Transport с MaxIdleConns/MaxIdleConnsPerHost и IdleConnTimeout.
// 32. Включи/выключи Keep-Alive и сравни время на 50 вызовов (микробенчмарк).
// 33. Настрой TLSClientConfig (InsecureSkipVerify=true) для локального самоподписанного.
// 34. Ограничь MaxConnsPerHost и проверь очередность при 100 параллельных запросах.
// 35. Используй httptrace.ClientTrace, чтобы залогировать DNS/Connect/TLS Handshake.
// 36. Реализуй собственный RoundTripper, который добавляет заголовок X-Trace-Id.
// 37. Сделай cookie-jar для клиента и проверь, что сервер видит cookie на втором запросе.
// 38. Реализуй cancelation server push: длинный ответ, клиент рвёт соединение — сервер видит ctx.Done().
// 39. Проверь сжатие: добавь Accept-Encoding:gzip; распакуй при чтении, если gzip.
// 40. Ограничь скорость чтения/записи через io.LimitedReader / обёртку-ридер-шейпер.

// --------------------------------------
// Блок E. HTTP: JSON/валидация/ошибки
// --------------------------------------

// 41. Прими JSON {"name": "..."}; проверь обязательные поля; верни 422 при ошибке валидации.
// 42. Возвращай ошибки в формате {"error": "..."} с корректным кодом.
// 43. Оборачивай ошибки через fmt.Errorf("%s: %w", op, err) и логируй причину.
// 44. Установи заголовок X-Request-ID (генерируй) и прокидывай его в логи.
// 45. Сделай middleware recovery: перехватывай panic и отдавай 500 без падения процесса.
// 46. Верни 405 для неподдерживаемого метода; добавь Allow заголовок.
// 47. Поддержи If-Modified-Since для GET /resource с Last-Modified.
// 48. Имплементируй простую rate-limit: X запросов в окно T (по IP), 429 при превышении.
// 49. Добавь CORS: для /api принимай Origin и отвечай на OPTIONS корректно.
// 50. Протестируй handler через httptest.NewRecorder и таблицу тестов.

// --------------------------------------
// Блок F. HTTP-тестирование и httptest
// --------------------------------------

// 51. Напиши unit-тест на JSON-хендлер с проверкой статуса и тела.
// 52. Подними httptest.NewServer, дерни его реальным http.Client.
// 53. Смоделируй медленный сервер в тесте (time.Sleep) и проверь таймаут клиента.
// 54. Тест редиректов с CheckRedirect (ожидаем ошибку при 4+ переходах).
// 55. Тест загрузки файла: multipart POST; проверь сохранённый размер.
// 56. Тест middleware: обёртка пишет код ответа — заассерть его.
// 57. Тест graceful: вызови srv.Shutdown(ctx) и проверь, что listener закрыт.
// 58. Тест SSE: установи короткий контекст, убедись, что соединение закрывается.
// 59. Фазз-тест JSON декодера: случайные тела -> не паниковать, корректные ошибки.
// 60. Бенчмарк: сравни JSON vs gob для простого DTO (опционально).

// ---------------------------
// Блок G. TCP-сервер: база
// ---------------------------

// 61. net.Listen("tcp", ":9090"); в цикле Accept -> горутина handle(conn).
// 62. Эхо-сервер: читаешь строку, отправляешь обратно; bufio.Reader/Writer.
// 63. Установи SetReadDeadline и SetWriteDeadline (по 5s) на соединении.
// 64. Веди счёт активных соединений (atomic.Int64); выведи в лог на connect/disconnect.
// 65. Сделай graceful stop TCP: контекст -> закрыть listener -> дождаться wg.Wait().

// ----------------------------------
// Блок H. TCP-протоколы/фрейминг
// ----------------------------------

// 66. Реализуй «line-based» протокол: сообщения разделены '\n'.
// 67. Реализуй «length-prefixed»: uint32 длина (binary.BigEndian) + payload.
// 68. Реализуй «delimited-bytes»: 0x00 как разделитель; обработай escape 0x00 внутри.
// 69. Добавь простую команду PING -> PONG (протокол текстовый).
// 70. Проверяй размер кадра: отклоняй >1MB с кодом ошибки и закрытием соединения.

// ------------------------------
// Блок I. TCP-клиент: база
// ------------------------------

// 71. net.DialTimeout("tcp", addr, 2s); отправь строку; прочитай ответ.
// 72. Сделай CLI: stdin -> сервер, сервер -> stdout; выход по "quit".
// 73. Реализуй reconnect с backoff при разрыве; сохраняй непрочитанные сообщения.
// 74. Добавь context.CancelFunc для прерывания блокирующего Read.
// 75. Проверь многосоединённость: 20 клиентов параллельно общаются с сервером.

// -----------------------------------
// Блок J. TCP: конкурентность и чат
// -----------------------------------

// 76. Сделай чат-сервер: map[connID]*Client, broadcast в отдельной горутине.
// 77. Регистрация клиента: присвоить уникальный id, отправить приветствие.
// 78. Команда /nick для смены ника; распространить событие всем.
// 79. Удали клиента из реестра при ошибке записи или EOF.
// 80. Защити реестр RWMutex или единственным «владельцем»-горутиной.

// ---------------------------------------
// Блок K. TCP: производительность/безопасность
// ---------------------------------------

// 81. Буферизуй запись через bufio.Writer; сравни с net.Conn.Write в бенче.
// 82. Введи write-queue (chan []byte) на клиента; не блокируй reader.
// 83. Ограничь QPS клиента (token bucket) на сервере.
// 84. Установи TCP keepalive через net.Dialer{KeepAlive: ...}.
// 85. Протокол handshake: сервер шлёт версию, клиент подтверждает; иначе разрыв.

// ----------------------------------
// Блок L. TCP: тестирование/decoder
// ----------------------------------

// 86. Используй net.Pipe для теста декодера length-prefixed.
// 87. Фазз-тест decoder: случайные байты -> без паник, корректные ошибки.
// 88. Тест дедлайнов: проверь, что ReadDeadline срабатывает на «молчаливом» клиенте.
// 89. Тест эхо: параллельные клиенты получают корректные ответы.
// 90. Тест graceful: закрытие listener прерывает Accept без утечки горутин.

// --------------------------------------
// Блок M. HTTP/TCP: чистая архитектура
// --------------------------------------

// 91. Выдели слой Service с интерфейсом; HTTP/TCP обёртки лишь (де)сериализация.
// 92. Ошибки домена -> коды HTTP: маппинг в одном месте (adapter).
// 93. Конфиг через env + флаги: addr, timeouts, limits; валидация.
// 94. Логгер-интерфейс + middleware для request-id и времени выполнения.
// 95. Пакет internal/{httpserver,tcpserver,service,storage,domain} минимально организуй.

// --------------------------------------
// Блок N. Разное полезное (мини-практикум)
// --------------------------------------

// 96. Мини-прокси: /proxy?url=... — скачай по клиенту, верни клиенту заголовки/статус/тело (часть заголовков отфильтровать).
// 97. SSE <-> TCP-мост: TCP-сообщения ретранслировать в SSE на HTTP клиенты.
// 98. Healthz aggregator: HTTP сервер собирает метрики с TCP сервера по внутреннему протоколу.
// 99. HTTP→TCP gateway: POST /msg -> TCP-серверу message; верни ответ.
// 100. Профилирование: добавь net/http/pprof на /debug/pprof; проверь в браузере.
