package main

// 1. Напиши TCP-сервер на `localhost:6000`, который принимает 
// одно сообщение и печатает его.


// 2. Напиши TCP-клиент, который подключается к серверу 
// и отправляет строку `"ping"`.


// 3. Измени сервер так, чтобы он возвращал `"pong\n"` 
// в ответ на `"ping\n"`.


// 4. Добавь бесконечный цикл обработки входящих 
// соединений: каждое — в своей горутине.


// 5. Добавь логгирование IP-адреса каждого 
// подключившегося клиента (`conn.RemoteAddr()`).


// 6. Добавь `defer conn.Close()` в хендлер, 
// чтобы не утекали соединения.


// 7. Ограничь обработку клиента буфером 
// в `[]byte` на 32 байта.


// 8. Преобразуй полученное сообщение в верхний 
// регистр и отправь клиенту обратно.


// 9. Реализуй простую команду `"echo: <msg>"`, 
// которая возвращает `<msg>`, используя `strings.HasPrefix`.


// 10. Добавь структуру `Client{id, conn}`, 
// и используй `map[int]Client` для отслеживания подключений.


// 11. Добавь мьютекс к мапе клиентов, если 
// сервер обрабатывает соединения параллельно.


// 12. Используй интерфейс `io.Reader` вместо `conn.Read` 
// напрямую, через `bufio.NewReader`.


// 13. Реализуй команду `"quit"` — если клиент её 
// прислал, соединение закрывается.


// 14. Добавь лог серверу: на каждое соединение 
// пиши `"Client X connected"`, `"Client X disconnected"`.


// 15. Реализуй broadcast — каждое сообщение от 
// клиента рассылается всем подключённым.


// 16. Добавь таймауты: `conn.SetReadDeadline(time.Now().Add(10 * time.Second))`.


// 17. Реализуй сервер, который принимает JSON строку и 
// распарсивает её в `struct{Msg string}`.


// 18. Ограничь сервер на максимум 5 одновременных 
// подключений (`chan struct{}` семафор).


// 19. Добавь логирование ошибок чтения и записи 
// в клиентский хендлер.


// 20. Раздели `main.go` на отдельные файлы: `server.go`, 
// `client.go`, `handler.go` — и переиспользуй интерфейсы.

