package main

// Задание 1
// Сделай горутину, которая печатает `"Привет"` через `time.Sleep(2 * time.Second)`.

// Задание 2
// Сделай `select` с `time.After(1 * time.Second)`. Напечатай `"timeout"`,
// если в канал ничего не пришло.

// Задание 3
// Создай таймер через `time.NewTimer(2 * time.Second)`.
// Дождись `<-timer.C` и выведи `"таймер сработал"`.

// Задание 4
// Создай `ticker := time.NewTicker(1 * time.Second)`,
// слушай `ticker.C` в горутине и выводи `Tick`. Через 3 секунды останови тикер.

// Задание 5
// Запусти операцию, которая завершается за 3 секунды,
// но используй `select` с `time.After(2 * time.Second)`. Выведи `"тайм-аут"`.

// Задание 6
// Сделай 3 операции, каждая завершается через `i` секунд.
// Используй `select` и `time.After(4 * time.Second)` — обрабатывай тех, кто успел.

// Задание 7
// Сделай таймер через `time.NewTimer`, но останови
// его до того, как он сработает. Проверь, что ничего не напечаталось.

// Задание 8
// Создай `select` с двумя `time.After` (2s и 1s).
// Кто сработает первым?

// Задание 9
// Реализуй heartbeat: `ticker` каждую секунду шлёт `"пульс"`.
// После 5 пульсов — остановись.

// Задание 10
// Создай обработчик задачи, который должен завершиться за 2s,
// иначе — выводится `превышено время ожидания`.

// Задание 11
// Имплементируй цикл, который каждые 500ms опрашивает
// `jobQueue <-chan string`. Если ничего нет — выводи `"ожидание..."`.

// Задание 12
// Сделай отложенный запуск функции: `time.AfterFunc(2 * time.Second, func() {...})`.

// Задание 13
// Создай таймер, запускающийся на 5 секунд, но вызывай `timer.Reset(2 * time.Second)` на второй секунде. Что произойдёт?

// Задание 14
// Создай задачу, где `main()` ждёт `done <-chan struct{}` или `<-time.After(1 * time.Second)`. Если тайм-аут — выход.

// Задание 15
// Сделай цикл, в котором каждую секунду обрабатываются новые задания. Если заданий нет — `Sleep(500ms)`.

// Задание 16
// Симулируй утечку: в цикле создаётся `time.After`, но его результат не читается. Что произойдёт со временем?

// Задание 17
// Правильно организуй повторяющуюся задачу через `for { select { case <-ticker.C: ... } }`.

// Задание 18
// Имплементируй `watchdog`: если событие не приходит в канал `ping <-chan struct{}` в течение 2s — выводи `"watchdog timeout"`.

// Задание 19
// Сделай отправку в канал с тайм-аутом: если канал занят, через `select` с `time.After` выведи `"send timeout"`.

// Задание 20
// Построй цикл обработки, где каждый запрос обрабатывается не дольше `X` времени (`select` с `time.After`). Проследи, чтобы цикл не завис.
