package main

// Задание 1
// Реализуй пул из 5 воркеров, которые читают числа из `jobs` и пишут квадрат в `results`.


// Задание 2
// Переделай `jobs` на структуру `Job{ID int, Value int}`. 
// Каждый воркер возвращает `JobResult{ID, Result}`.


// Задание 3
// Добавь `WaitGroup`, чтобы дождаться завершения всех воркеров. 
// Закрой `results` только после `wg.Wait()`.


// Задание 4
// Передай воркерам `context.Context`. Заверши все worker'ы, 
// если `context` отменён (например, через timeout).


// Задание 5
// Добавь `sync.Mutex` и общий счётчик выполненных задач. 
// Выводи итог после завершения пула.


// Задание 6
// Сделай интерфейс `Worker`, с методом `Process(Job) JobResult`. 
// Имплементация логирует свою работу.


// Задание 7
// Сделай логгер-интерфейс `Logger.Log(msg string)`. 
// Каждый воркер пишет «start» и «done» по каждой задаче.


// Задание 8
// Добавь канал `errs`, куда воркеры пишут ошибку, если 
// входной `Value < 0`. Главная горутина собирает ошибки.


// Задание 9
// Воркеры должны спать 100 мс между задачами (rate limit). 
// Используй `time.Sleep` или `time.Ticker`.


// Задание 10
// Сохраняй `JobResult` в `sync.Map` по `JobID`. 
// После завершения пула выведи все результаты.


// Задание 11
// Создай тест: запускай пул с 100 задачами. 
// Измерь общее время выполнения (через `time.Since`).


// Задание 12
// Сделай динамически настраиваемый размер пула: 
// количество воркеров задаётся через `flag`.


// Задание 13
// Реализуй graceful shutdown через `os.Signal` (Ctrl+C). 
// Заверши worker'ы и закрой все каналы корректно.


// Задание 14
// Сделай очередь задач ограниченного размера 
// (например, `jobs := make(chan Job, 10)`) и проверь блокировки.


// Задание 15
// Модифицируй пул: после обработки каждой задачи worker 
// вызывает колбэк-функцию `OnDone(result)`.


// Задание 16
// Добавь подсчёт успешно обработанных и ошибочных 
// задач с использованием `atomic.Int64`.


// Задание 17
// Сделай `Dispatcher`-структуру, которая запускает N воркеров 
// и управляет каналами `jobs`, `results`.


// Задание 18
// Сделай интерфейс `PoolController`, с методами `Start(n int)`, 
// `Stop()`, `Submit(Job)`. Реализуй управление пулом.


// Задание 19
// Сделай конфиг `Config{MaxWorkers int, Timeout time.Duration}`, 
// передаваемый в пул через context.


// Задание 20
// Сделай воркер, который обрабатывает задачи из нескольких 
// очередей: `jobsHigh`, `jobsLow`, выбирает приоритетные.


