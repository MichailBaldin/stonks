package main

// Задание 1
// Напиши функцию, которая открывает файл и **гарантированно**
// закрывает его через `defer`.

// Задание 2
// Создай `sync.Mutex`, захвати его через `Lock()` и **освободи**
// в конце с помощью `defer Unlock()`.

// Задание 3
// Сделай функцию `safeDivide(a, b int) int`, которая возвращает `0`,
// если произошло деление на ноль, используя `recover`.

// Задание 4
// Создай функцию `danger()`, вызывающую `panic("oops")`.
// Оберни её вызов в другую функцию, где через `defer + recover` отлавливается паника.

// Задание 5
// Проверь: сработает ли `recover()`, если он **вне** `defer`.
// Объясни поведение.

// Задание 6
// Создай defer-цепочку из трёх `defer`
// и проверь порядок их выполнения.

// Задание 7
// В цикле запускай функцию с `defer`, и сравни: `defer`
// внутри цикла или вне — где создаётся больше горутин и аллокаций?

// Задание 8
// Напиши обёртку `func safe(f func())`, которая ловит
// панику внутри `f()` и логирует ошибку, не давая программе упасть.

// Задание 9
// Создай структуру `Task{ID int}`. Сделай метод `Run()`,
// который вызывает `panic`, если `ID < 0`, и `recover()` для безопасной обработки.

// Задание 10
// Интегрируй `recover` в воркер пул: если воркер падает,
// он перезапускается и продолжает обработку других задач.

// Задание 11
// Добавь логгирование ошибки из `recover()` с timestamp
// и стеком (`debug.Stack()`).

// Задание 12
// Сделай функцию `WithRecovery(fn func())`, которая
// возвращает `true`, если `panic` был перехвачен.

// Задание 13
// Сделай HTTP handler, в котором `defer` ловит `panic`
// и возвращает 500 без падения сервера.

// Задание 14
// Сымитируй `panic` в goroutine и покажи, что `recover()`
// в main не ловит панику из другой горутины.

// Задание 15
// Сделай `defer func() { fmt.Println("done") }()` внутри `for`,
// и объясни разницу, если ставить `defer` вне цикла.

// Задание 16
// Создай `panic` с кастомной структурой ошибки (`type MyError struct`),
// перехвати её через `recover()` и проверь тип через type assertion.

// Задание 17
// Имплементируй `TaskRunner` с методом `Run(f func())`,
// который ловит все `panic`, логирует, и продолжает работу.

// Задание 18
// Добавь в `defer` обработку времени выполнения: логируй,
// сколько заняла работа функции.

// Задание 19
// Сделай универсальный `SafeGo(fn func())`, который запускает `fn`
// в горутине и ловит `panic` внутри.

// Задание 20
// Напиши мини-фреймворк: `RunWithRecovery(name string, fn func())`,
// логирующий имя задачи, ошибку и стек при `panic`.
