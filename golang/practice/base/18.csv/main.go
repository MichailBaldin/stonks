package main

// 1. Открой файл `data.csv`, считай все строки с помощью `csv.NewReader(...).ReadAll()`.

// 2. Создай CSV-файл `output.csv`, запиши туда заголовки `id,name` и одну строку данных.

// 3. Считай CSV построчно через цикл `reader.Read()`, пока не `io.EOF`.

// 4. Преобразуй строки из CSV в `User{ID int, Name string}` — используй `strconv.Atoi`.

// 5. Добавь валидацию: строка должна содержать ровно 2 поля, иначе логируй ошибку.

// 6. Запиши `[]User` в CSV-файл, каждую строку — с помощью `writer.Write`.

// 7. Установи `reader.Comma = ';'` и считай CSV, разделённый точкой с запятой.

// 8. Считай CSV с включёнными кавычками (`"Ivan"`) и `LazyQuotes = true`.

// 9. Используй `TrimLeadingSpace = true` — строки должны быть очищены от пробелов.

// 10. Пропусти первую строку (заголовки) в CSV при чтении.

// 11. Преобразуй CSV `id,name,email` в `map[int]string` (id → email).

// 12. Поддержи чтение CSV с UTF-8 строками (например, `"Привет"`).

// 13. Выведи номер строки и содержимое, если в CSV меньше или больше 2 полей.

// 14. Напиши функцию `LoadUsersFromCSV(filename string) ([]User, error)`.

// 15. Считай CSV из `strings.NewReader(csvString)` — без файлов.

// 16. Проверь, что `writer.Flush()` вызывается всегда через `defer`.

// 17. Сохрани CSV не в файл, а в `bytes.Buffer` и выведи его содержимое.

// 18. Установи `writer.UseCRLF = true` и проверь, что строки оканчиваются `\r\n`.

// 19. Добавь генерацию CSV с 1000 строк, где каждая
// строка — `fmt.Sprintf("%d,User%d", i, i)`.

// 20. Обработай ошибку чтения: если `strconv.Atoi(fields[0])`
// вернул ошибку — логируй и пропусти строку.
