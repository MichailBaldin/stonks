package main

// Задание 1
// Импортируй пакет `golang.org/x/sync/errgroup`. Создай `errgroup.Group` 
// и запусти две горутины: одна возвращает `nil`, вторая — ошибку.


// Задание 2
// Добавь `g.Wait()` и проверь, что вернётся первая ошибка, если она была.


// Задание 3
// Сделай `for i := 0; i < 5; i++`, запускай 5 горутин через `g.Go(...)`. 
// Не забудь захват переменной `i := i`.


// Задание 4
// Внедри `errgroup.WithContext()`. Каждая горутина должна проверять `ctx.Done()` 
// и завершаться при отмене.


// Задание 5
// Имплементируй `fetchURLs(urls []string) error`, где каждая URL 
// загружается параллельно через `http.Get()`, но при ошибке все отменяются.


// Задание 6
// Добавь `time.Sleep()` в одну из горутин, проверь, что она не 
// успевает выполниться после ошибки из другой.


// Задание 7
// Сделай структуру `Job{ID int}`. Запусти N параллельных задач, 
// каждая из которых печатает ID и возвращает ошибку, если ID нечётный.


// Задание 8
// Добавь логирование: когда горутина стартует, когда завершается и что возвращает.


// Задание 9
// Сделай `ProcessTasks(ctx context.Context, jobs []Job) error`, 
// используй `WithContext`, завершай по первой ошибке.


// Задание 10
// Запусти 10 горутин, каждая из которых читает из общего канала 
// заданий (worker pool), но завершаются все при первой ошибке.


// Задание 11
// Используй `sync.Map` для сбора результатов параллельных задач. 
// Сохраняй ID → результат.


// Задание 12
// Реализуй `ParallelMap[T any, R any]`, обобщённую функцию с дженериками, 
// использующую `errgroup` для применения `func(T) (R, error)` к слайсу.


// Задание 13
// Добавь лимит на параллелизм: запускай максимум 3 задачи одновременно. 
// Используй семафор (канал `chan struct{}`).


// Задание 14
// Покажи, что `Wait()` блокирует до завершения всех задач, даже если 
// одна уже вернула ошибку.


// Задание 15
// Проверь поведение, если горутина "зависает" 
// (например, `select{}`) — что будет с `ctx`?


// Задание 16
// Проверь `err := g.Wait()` в двух случаях: (1) все задачи успешны, 
// (2) хотя бы одна вернула `error`.


// Задание 17
// Сделай `safeGo(g *errgroup.Group, fn func(ctx context.Context) error)`, 
// обёртку с логгированием запуска, ошибки и отмены.


// Задание 18
// Сделай мини-профайлер: измеряй время выполнения каждой 
// горутины через `time.Since(start)`.


// Задание 19
// Интегрируй `errgroup` в HTTP middleware: логируй панику и 
// возвращай 500, если что-то пошло не так.


// Задание 20
// Реализуй `ConcurrentReduce(items []int, fn func(int) error) error`, 
// обрабатывающую элементы параллельно с отменой по первой ошибке.


