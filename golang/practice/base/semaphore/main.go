package main

// Задание 1
// Реализуй семафор на `chan struct{}` с буфером 3. Разреши запускать 
// не более 3 горутин одновременно.


// Задание 2
// Добавь `defer <-sem` после `sem <- struct{}{}` — обеспечь 
// автоматическое освобождение слота.


// Задание 3
// Вынеси семафор в структуру `Semaphore`, 
// добавь методы `Acquire()` и `Release()`.


// Задание 4
// Реализуй метод `Do(fn func())` в `Semaphore`, 
// который берёт слот, вызывает `fn()` и потом освобождает слот.


// Задание 5
// Добавь поддержку `context.Context`: метод `Acquire(ctx)` 
// должен возвращать `false`, если context отменён.


// Задание 6
// Создай воркер пул, но вместо фиксированного числа 
// воркеров используй семафор: количество активных горутин ≤ 5.


// Задание 7
// Сделай тест: запусти 100 задач, выведи время старта/завершения 
// каждой — покажи, что параллелизм ограничен.


// Задание 8
// Реализуй интерфейс `Limiter`, с методами 
// `Acquire(context.Context) error`, `Release()`. 
// `Semaphore` должен удовлетворять интерфейсу.


// Задание 9
// Добавь atomic-счётчик текущих активных операций. 
// Показывай `Active: N` каждые 200ms.


// Задание 10
// Создай `Job{ID, UserID}`. Используй `sync.Map` для хранения 
// отдельных семафоров на каждого `UserID`.


// Задание 11
// Добавь `TryAcquire() bool`: возвращает `false`, если 
// слот недоступен сразу (без блокировки).


// Задание 12
// Добавь защиту от panic: если в `fn()` случилась ошибка, 
// всё равно освободи слот (через `recover()`).


// Задание 13
// Интегрируй семафор в HTTP-сервер: не более 10 одновременных 
// запросов. Остальные должны ждать или получать 429.


// Задание 14
// Сделай комбинированный limiter: семафор + rate limiter. 
// Разрешай одновременно 5 потоков, но не чаще 20 в секунду.


// Задание 15
// Сделай тест с `x/sync/semaphore.Weighted`: захватывай `2 слота` 
// сразу. Выполняй задачу, если доступно хотя бы 2.


// Задание 16
// Имплементируй `TaskQueue`, которая обрабатывает задачи из канала 
// с помощью семафора, контролирующего конкурентность.


// Задание 17
// Добавь логгер, логирующий `acquire`, `release`, `cancel`, `panic`, 
// с ID задачи и timestamp.


// Задание 18
// Реализуй `BoundedExecutor`, который ограничивает общее количество 
// активных задач и умеет дожидаться завершения всех.


// Задание 19
// Переделай `Semaphore` в middleware (HTTP/GRPC), который отказывает 
// при перегрузке и логирует попытки превышения.


// Задание 20
// Сделай `DynamicSemaphore`, который может менять лимит в рантайме 
// (через канал `config <- int`).


