package main

// Задание 1
// Создай два канала `ch1` и `ch2`. В первой горутине отправь в `ch1` через 1 секунду,
// во второй — в `ch2` через 2 секунды. Используй `select`,
// чтобы вывести первый пришедший результат.

// Задание 2
// Используй `select` с `time.After(2 * time.Second)` и `ch`, в который ничего не придёт. Выведи `"timeout"`.

// Задание 3
// Добавь `default` в `select`. Если ни один канал не готов — выведи `"no data"`.

// Задание 4
// Сделай цикл, где `select` читает из `input <-chan string`, но прерывается по `done <-chan struct{}`.

// Задание 5
// Реализуй горутину, которая ждёт данные на двух каналах. Когда получает от любого — печатает `"received"`.

// Задание 6
// Модифицируй предыдущую: если оба канала неактивны — напиши `"idle"` через `default`.

// Задание 7
// Создай воркер: он читает из `jobs <-chan int`, а если приходит `quit <-chan struct{}`, выходит.

// Задание 8
// Сделай тайм-аут на чтение из канала. Если данные не приходят за 100 мс — выводится `"slow"`.

// Задание 9
// Сделай `chan int` и `chan string`, каждая горутина пишет в свой. Используй `select` для получения любого типа.

// Задание 10
// Используй `select` для циклического чтения из входного канала и выхода по `done`.

// Задание 11
// Реализуй неблокирующую запись в канал: `select` с `default` — если канал заполнен, выведи `"skip"`.

// Задание 12
// Сделай цикл, который читает из двух каналов (`fast`, `slow`). Приоритет отдаётся `fast`, если данные есть.

// Задание 13
// Сделай воркера с `select`, который завершает работу по `ctx.Done()` (контекст пока не используем, просто канал).

// Задание 14
// Введи канал `cancel`, после 1 секунды отправь в него. Все воркеры должны остановиться через `select`.

// Задание 15
// Имплементируй демультиплексер: `input <-chan int` распределяет данные в `even` и `odd` каналы через `select`.

// Задание 16
// Создай горутину, которая каждые 200 мс шлёт `"ping"`, но выходит по `done`.

// Задание 17
// Сделай `select` с 3 входными каналами (`a`, `b`, `c`). Обрабатывай любой, кто первым готов.

// Задание 18
// Симулируй балансировку: 3 источника (продуктора) пишут в общий канал, воркер через `select` читает.

// Задание 19
// Сделай систему heartbeat: `ticker := time.NewTicker(1 * time.Second)` — слушай `ticker.C` и выводи "alive".

// Задание 20
// Имплементируй shutdown: `main()` ждёт `done <-chan struct{}` через `select`. После сигнала — завершает работу.
