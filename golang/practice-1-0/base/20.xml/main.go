package main

// 1. Создай структуру `User{ID int, Name string}` и сериализуй её в XML.


// 2. Распарси XML `<user><id>1</id><name>Ivan</name></user>` в структуру `User`.


// 3. Добавь тег `xml:"user"` к корню и проверь, что появляется нужный тег в выходном XML.


// 4. Добавь атрибут `type="admin"` к `User` с тегом `xml:"type,attr"`.


// 5. Сериализуй слайс `[]Book` в структуру `Library`, где `<book>` повторяются.


// 6. Распарси XML с множественными `<book>` в `Library{Books []Book}`.


// 7. Добавь вложенность: `Library` содержит `[]Section`, а `Section` — `[]Book`.


// 8. Сериализуй структуру, в которой одно поле пропущено (`xml:"-"`) — проверь результат.


// 9. Сделай поле `Content` с тегом `xml:",chardata"` и проверь, что текст попадает в тело тега.


// 10. Прочитай XML из `strings.NewReader` с помощью `xml.NewDecoder`.


// 11. Используй `Token()` из `xml.Decoder`, чтобы поэлементно прочитать XML.


// 12. Добавь в структуру поле `Raw string \`xml:",innerxml"\`\` — получи внутреннее содержимое тега.


// 13. Распарси XML с вложенными тегами без вложенной структуры (например, `[]xml.Token`).


// 14. Обработай случай, когда входной XML имеет неправильный корень — выдаёт ошибку.


// 15. Добавь поддержку атрибутов: `<book id="42" title="Go">` → поля `ID`, `Title`.


// 16. Прочитай XML, в котором есть необязательное поле (`omitempty` здесь не работает).


// 17. Сериализуй структуру с датой `time.Time`, используя `Format("2006-01-02")`.


// 18. Прочитай XML в анонимную структуру и выведи `Name`.


// 19. Сравни поведение Marshal/Unmarshal, если структура не экспортируется (`type user struct`).


// 20. Сериализуй структуру с вложенной XML-структурой как raw string (`xml:",innerxml"`) и добавь свои теги вручную.


