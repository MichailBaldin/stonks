package main

// 1. Создай слайс из 5 целых чисел и выведи длину и ёмкость.

// 2. Создай nil-слайс и проверь: равен ли он nil? Что у него с `len` и `cap`?

// 3. Сделай слайс через `make([]int, 3, 5)` и заполни числами от 1 до 3.

// 4. Срежь массив `[10, 20, 30, 40, 50]`, чтобы получить `[20, 30]`.

// 5. Удали третий элемент из слайса целых чисел (index = 2).

// 6. Создай функцию, принимающую `[]int`, и увеличивающую каждый элемент в 2 раза.

// 7. Добавь 3 элемента в слайс и покажи, что `cap` может увеличиться.

// 8. Создай копию слайса через `copy()`, измени копию, и убедись, что оригинал не меняется.

// 9. Создай слайс структур `User{name string}`. Добавь 3 пользователей.

// 10. Создай двумерный слайс `[][]int` и заполни как матрицу 2×2.

// 11. Удали первый элемент слайса. Объясни, почему это может привести к удержанию памяти.

// 12. Сравни `[]int{}` и `nil`-слайс. В чём поведение различается?

// 13. Напиши функцию `Sum([]int) int`, которая возвращает сумму всех элементов.

// 14. Реализуй функцию `Reverse([]int)`, разворачивающую слайс.

// 15. Через цикл добавь 10 элементов в слайс, выводи `cap` после каждого `append`.

// 16. Передай слайс строк в функцию и измени один элемент — проверь, изменится ли оригинал.

// 17. Реализуй фильтрацию: из слайса оставить только чётные числа.

// 18. Напиши функцию `Clone([]int) []int`, которая возвращает независимую копию.

// 19. Создай слайс указателей на структуры, измени данные по одному из указателей.

// 20. Передай слайс в функцию, в которой происходит `append`,
// и объясни, почему результат может не сохраниться.

// 21. Отсортируй `[]int` по убыванию с помощью `sort.Slice`.

// 22. Сделай обёртку `type IntSlice []int` и добавь метод `Max()`.

// 23. Создай слайс из `map[string]int`, добавь несколько мап,
// выведи среднее по полю `"age"`.

// 24. Добавь проверку: не выходишь ли за границы слайса при доступе `s[i]`.

// 25. Объедини два слайса: добавь `s2...` в `s1` через `append`.

// 26. Передай слайс, созданный через `make`, в функцию,
// где будет `append`, и сравни указатель до/после.

// 27. Покажи, как растёт `cap` слайса после каждого `append`.

// 28. Реализуй удаление элемента по индексу с сохранением порядка через `copy()`.

// 29. Создай слайс структур, у которых есть вложенный `[]string`.
// Измени элемент внутри вложенного слайса.

// 30. Реализуй функцию `Chunk([]int, size int) [][]int`,
// разбивающую слайс на чанки по заданному размеру.
