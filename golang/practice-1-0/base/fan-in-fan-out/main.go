package main

// Задание 1
// Создай канал `jobs`, запусти 3 worker-горутины, каждая умножает
// полученное число на 2 и пишет результат в `results`.

// Задание 2
// Модифицируй воркеров: каждый пишет в `results` структуру
// `Result{id int, value int}`, где `id` — номер задачи.

// Задание 3
// Создай интерфейс `Worker` с методом `Process(input int) Result`.
// Запусти пул таких воркеров, реализующих интерфейс.

// Задание 4
// Используй `sync.WaitGroup` для отслеживания завершения всех
// воркеров и корректного закрытия канала `results`.

// Задание 5
// Добавь поддержку `context.Context` в worker'ы. Заверши все
// горутины через `context.WithTimeout`.

// Задание 6
// Сделай буфер в `results`, равный количеству задач. Убери
// буфер и понаблюдай — будет ли блокировка?

// Задание 7
// Добавь `sync.Mutex`: каждый worker считает, сколько задач
// он обработал. Итог выводится после завершения всех.

// Задание 8
// Добавь `atomic.Int32` счётчик общего количества обработанных
// задач. Выводи прогресс в stdout.

// Задание 9
// Используй `sync.Map` для хранения статуса задач (`started`, `done`)
// по `id`. Обновляй в воркерах.

// Задание 10
// Создай интерфейс `Logger` с методом `Log(msg string)`.
// Подключи логгирование старта и конца работы каждого worker'а.

// Задание 11
// Добавь канал `errs` для ошибок. Если worker получает ошибку,
// он отправляет её в этот канал. Главная горутина читает и логирует.

// Задание 12
// Добавь в воркер rate-limit: не обрабатывать задачи чаще
// чем раз в 100ms. Используй `time.Ticker`.

// Задание 13
// Добавь измерение времени выполнения каждой задачи.
// Собери топ-3 самых долгих обработок и выведи их.

// Задание 14
// Переделай `jobs` на структуру `Job{ID int, Payload int}`.
// Worker работает уже с этой структурой.

// Задание 15
// Worker возвращает `JobResult{JobID int, Value int, Err error}`.
// В main выводятся все успешные и ошибочные.

// Задание 16
// Реализуй `fan-in`: все worker'ы пишут в один общий канал `results`,
// main читает и агрегирует их.

// Задание 17
// Создай интерфейс `Dispatcher` с методом `Dispatch(jobs <-chan Job)`.
// Имплементация управляет worker-пулом и routing'ом задач.

// Задание 18
// Реализуй динамический пул воркеров: во время выполнения можно
// уменьшать или увеличивать их количество (по сигналу или флагу).

// Задание 19
// Реализуй graceful shutdown: при получении Ctrl+C (сигнала `os.Interrupt`)
// отправь `context.CancelFunc` всем worker'ам.

// Задание 20
// Сделай отдельную горутину, которая считывает результаты и печатает
// прогресс: «Выполнено X из Y задач».
