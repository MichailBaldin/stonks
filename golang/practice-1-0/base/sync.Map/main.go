package main

// Задание 1
// Создай `sync.Map`, запиши в него пару `("foo", 42)` и считай значение, выведи его.



// Задание 2
// Добавь проверку: если значение уже есть, не перезаписывай. Используй `LoadOrStore`.


// Задание 3
// Удаляй ключ `"foo"` из `sync.Map` и проверь, что `Load` возвращает `ok == false`.


// Задание 4
// Запусти 5 горутин, каждая из которых сохраняет свой ID как ключ и значение. 
// Проверь, что все значения на месте.


// Задание 5
// Сделай структуру `User{ID int, Name string}` и сохраняй её в `sync.Map` по `ID`.


// Задание 6
// Добавь метод `GetUser(id int) (User, bool)` с type assertion и проверкой `ok`.


// Задание 7
// Создай `SafeRegistry` со встроенным `sync.Map`. 
// Добавь методы `Register(name string, val any)` и `Get(name string)`.


// Задание 8
// Сделай безопасную карту `sync.Map` с конкурентной 
// регистрацией обработчиков: `map[string]func() error`.


// Задание 9
// Имплементируй кэш для результатов: если значение 
// уже есть — вернуть его, иначе вызвать `expensiveComputation()` и сохранить.


// Задание 10
// Сделай `LoadOrStore()` с функцией-значением, 
// которое логирует, была ли вставка.


// Задание 11
// Сделай `sync.Map`, который хранит `atomic.Value` 
// по ключу. Каждая горутина обновляет одно значение.


// Задание 12
// Создай `sync.Map`, который хранит структуры 
// `Metrics{Hits int, Errors int}`. Каждая горутина инкрементирует `Hits`.


// Задание 13
// Итерация по `sync.Map` через `Range`: выведи все ключи и значения.


// Задание 14
// Создай структуру `Config`, обновляемую в `sync.Map` 
// под ключом `"config"`. Горутины читают конфиг через `Load()`.


// Задание 15
// Сделай пул горутин (10 штук), который получает задания 
// с ID, сохраняет результаты в `sync.Map[id] = result`.


// Задание 16
// Создай REST-like API с обработчиками, зарегистрированными 
// в `sync.Map[string]func(w http.ResponseWriter, r *http.Request)`.


// Задание 17
// Сделай безопасную очередь: каждая задача получает 
// уникальный `uuid` и сохраняется в `sync.Map` как `status`.


// Задание 18
// В `sync.Map` хранятся таймеры. При отмене — достаёшь 
// по ключу, вызываешь `Stop()` и удаляешь.


// Задание 19
// Построй `Registry`, реализующий интерфейс с методами 
// `Register(key string, val any)` и `MustGet(key string) any`.


// Задание 20
// Проведи тест: конкурентное чтение и запись в `sync.Map` 
// против `map + mutex`. Сравни стабильность и производительность.


