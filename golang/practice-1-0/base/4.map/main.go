package main

// 1. Создай `map[string]int`, добавь туда три пары: "one" → 1, "two" → 2, "three" → 3.

// 2. Прочитай значение по ключу `"two"` и выведи его, используя `v, ok := m["two"]`.

// 3. Удали ключ `"one"` из map и проверь, что его больше нет.

// 4. Посчитай количество элементов в map через `len(m)`.

// 5. Объяви переменную `var m map[string]int` и попробуй записать туда значение.
// Что произойдёт?

// 6. Создай map, где ключ — `int`,
// а значение — структура `User{Name string, Age int}`.
// Добавь 2 пользователя.

// 7. Обнови поле `Age` у пользователя в map, если значения — структура.
// Что произойдёт? Почему?

// 8. Переделай предыдущую задачу, чтобы значения
// были указателями: `map[int]*User`. Измени возраст.

// 9. Пройди по map через `for k, v := range m`
// и выведи все пары.

// 10. Суммируй значения всех чисел в map: `map[string]int{"a":1, "b":2, "c":3}`.

// 11. Создай `map[int]string` и наполни её из слайса строк, где индекс = ключ.

// 12. Проверь, есть ли ключ `42` в `map[int]string`, и выведи `"not found"`, если нет.

// 13. Используя вложенную `map[string]map[string]int`,
// добавь ключ `"outer" → "inner" → 100`.

// 14. Реализуй функцию `Keys(m map[string]int) []string`,
// возвращающую слайс всех ключей.

// 15. Реализуй `Invert(m map[string]int) map[int]string`,
// которая меняет местами ключи и значения.

// 16. Создай map, в которой значения — слайсы строк: `map[string][]string`.
// Добавь несколько тегов для категорий.

// 17. Удали все элементы map через `for k := range m { delete(m, k) }`.

// 18. Проверь поведение map в функции: передай map, измени элемент,
// верни map. Что произойдёт?

// 19. Создай map для подсчёта количества вхождений слов из слайса `[]string{"a", "b", "a", "c", "b", "a"}`.

// 20. Напиши функцию `GroupByLength([]string) map[int][]string`,
// группирующую слова по длине.

// 21. Создай `map[int][]int`, добавь в неё несколько слайсов,
// удали первый элемент из одного из них.

// 22. Используй `make(map[string]int, 1000)`
// и наполни map числами от 1 до 1000.

// 23. Сделай map с ключами-структурами `type Coord struct{X, Y int}`.
// Добавь несколько точек.

// 24. Создай `map[string]interface{}` и добавь туда строки,
// числа и вложенные map.

// 25. Преобразуй `map[string]string` в JSON строку с помощью `encoding/json`.

// 26. Из JSON-строки распарсь `map[string]interface{}`.
// Обратись к вложенному полю.

// 27. Напиши `CloneMap(m map[string]int) map[string]int`,
// возвращающую копию.

// 28. Реализуй `MergeMaps(a, b map[string]int) map[string]int`,
// объединяющую два отображения.

// 29. Передай map с указателями в горутину и измени значение.
// Объясни, почему работает.

// 30. Создай map, в которой значением является функция `func(int) int`.
// Пример: `"square"` → x², `"double"` → 2×x. Вызови нужную по ключу.

//=====================================================

// =======================
// Тренажёр: Maps (v1)
// =======================

// --- Блок A. Базовые операции ---

// 1. Объяви nil-map: var m map[string]int. Проверь m==nil и len(m).
// 2. Попробуй m["a"] = 1 на nil-map — ожидаем панику. Затем инициализируй m = make(map[string]int) и повтори запись.
// 3. Создай map литералом: m := map[string]int{"a":1, "b":2}. Выведи len и одно чтение m["a"].
// 4. Проверь идиому "comma ok": v, ok := m["c"]; выведи v и ok.
// 5. Удали ключ delete(m, "a"); проверь, что повторное delete не паникует.
// 6. Сделай make(map[string]int, 8) — подай hint на ёмкость; выведи len (cap недоступен).
// 7. Перебери map через for k, v := range m { ... }. Запусти несколько раз — зафиксируй, что порядок произволен.
// 8. Покажи, что m["x"]++ работает даже для отсутствующего ключа (нулевое значение).
// 9. Присвой по ключу новое значение поверх старого: m["b"]=10; проверь чтением.
// 10. Очисти map тремя способами: (а) m = make(map[string]int) (b) цикл delete (c) clear(m). Сравни эффекты для возможных копий ссылки.

// --- Блок B. Передача в функции ---

// 11. Напиши func Put(m map[string]int, k string, v int), вызови и проверь, что исходная map изменилась.
// 12. Покажи, что переназначение m = make(map[string]int) внутри функции НЕ влияет на исходную ссылку.
// 13. Напиши func ResetInPlace(m map[string]int) { clear(m) } и проверь, что исходная map стала пустой.
// 14. Реализуй Upsert: func Upsert(m map[string]int, k string, f func(int) int), которая читает текущее, применяет f и пишет обратно.
// 15. Сделай "удалить с возвратом": func DeleteGet(m map[string]int, k string) (int, bool) — вернуть старое значение и флаг существования.

// --- Блок C. Частые паттерны ---

// 16. Счётчик слов: по []string посчитай частоты map[string]int.
// 17. Множество через map[string]struct{}: добавь 3 элемента, проверь принадлежность и удаление.
// 18. Пересечение двух множеств (map[string]struct{}), верни новое множество.
// 19. Разность множеств A\B.
// 20. Дедупликация слайса строк с сохранением порядка через seen map[string]struct{}.

// --- Блок D. Итерация в определённом порядке ---

// 21. Собери срез ключей Keys([]) и отсортируй sort.Strings; пройдись по m в порядке ключей.
// 22. Отсортируй пары по значению: сформируй []struct{k string; v int}, отсортируй по v по убыванию.
// 23. Сформируй топ-N по значению из map[string]int.
// 24. Сгруппируй пользователей по городу: из []User -> map[string][]User.
// 25. Построй индекс по id: []User -> map[int]User (перезапись при дубликате id).

// --- Блок E. Вложенные структуры ---

// 26. map[string][]int: добавь элемент в срез по ключу, предварительно инициализировав пустым срезом при отсутствии ключа.
// 27. map[string]map[string]int: инкремент m[a][b] с безопасной инициализацией внутренней map.
// 28. "Инверсия" map[string]int -> map[int][]string (значение -> список ключей).
// 29. Глубокая копия map[string][]int (новая map и новые срезы).
// 30. Объединение двух map[string]int: merge с политикой "вторая перекрывает первую".

// --- Блок F. Ключи и сравнимость (comparable) ---

// 31. Используй массив как ключ: map[[2]int]int — посчитай счётчики для пар координат.
// 32. Используй struct как ключ (только сравнимые поля): type Key struct{ A int; B string }.
// 33. Попробуй (закомментируй) сделать ключом []int или map[string]int — зафиксируй ошибку компиляции и объясни почему.
// 34. Сравни поведение ключей-указателей: map[*User]int — две разные переменные с одинаковыми полями считаются разными ключами.
// 35. Покажи разницу между ключом struct и *struct в уникальности записей.

// --- Блок G. JSON и сериализация ---

// 36. Сериализуй map[string]int в JSON и обратно (encoding/json). Порядок полей в JSON не гарантируется.
// 37. Сериализуй map[int]string — зафиксируй, что ключи в JSON превращаются в строки.
// 38. Сериализуй map[string]any со значениями разных типов и прочитай обратно в map[string]any.
// 39. Преобразуй []Pair{Key,Val} в map и обратно (для стабильного порядка при выводе).
// 40. Сконструируй "плоский" JSON индекс: из []User -> map[string]int{"name":id}.

// --- Блок H. Безопасные модификации при обходе ---

// 41. Удаляй ключи во время range: for k := range m { if условие { delete(m,k) } } — покажи, что это корректно.
// 42. Построй фильтрованную map из исходной без модификации оригинала.
// 43. Разнеси объекты на две map по предикату (partition).
// 44. Реализуй CloneShallow map[string]int (поверхностная копия через make+range).

// --- Блок I. Производительность/границы API ---

// 45. Покажи, что cap(map) недоступен; инициализация make(map[K]V, n) — лишь hint для уменьшения перераспределений.
// 46. Инициализируй большую map, затем занули её clear(m); сравни с m = nil и с m = make(...), как ведёт себя len и запись/чтение.
// 47. Проверь, что чтение отсутствующего ключа даёт zero value типа значения (int=0, string="").
// 48. Реализуй EqualShallow(a,b map[string]int) bool без reflect: сравни len и значения по ключам.
// 49. Реализуй Diff(a,b map[string]int): какие ключи добавлены, удалены, изменены.
// 50. Напиши SafeGet(m map[string]int, k string, def int) int — вернуть значение или def, не меняя map.
