package main

// Задание 1
// Реализуй throttler через `chan struct{}` с буфером 3: 
// обрабатывай задачи максимум по 3 одновременно.


// Задание 2
// Добавь `defer <-throttle` внутри каждой горутины, 
// чтобы гарантировать освобождение слота.


// Задание 3
// Переделай throttler в структуру `Throttler`, с методом `Acquire()` и `Release()`.


// Задание 4
// Добавь метод `Do(f func())` в `Throttler`, 
// который оборачивает вызов с автоматическим `Acquire`/`Release`.


// Задание 5
// Поддержи `context.Context` в методе `Acquire(ctx)` — отменяй, 
// если контекст завершён.


// Задание 6
// Сделай воркер пул из 10 задач, но разрешай одновременно не 
// более 3 активных через `Throttler`.


// Задание 7
// Добавь atomic-счётчик текущих активных задач, чтобы в 
// реальном времени выводить «Active: N».


// Задание 8
// Сделай логгер-интерфейс `Logger.Log(msg string)` и 
// логируй `acquire`, `release`, `cancelled`.


// Задание 9
// Оберни `Throttler` в middleware: перед вызовом handler 
// проверяй `Acquire`, по `Release` заверши.


// Задание 10
// Интегрируй в HTTP сервер: одновременно обрабатывается 
// не более 5 входящих запросов.


// Задание 11
// Переделай `Throttler` на использование `sync.Cond` 
// вместо каналов (альтернативный способ).


// Задание 12
// Сделай комбинированный лимитер: `Throttler` ограничивает 
// одновременность, а `Ticker` — частоту.


// Задание 13
// Создай структуру `Job{ID int, Payload int}`, запускай 
// задачи с throttling и логированием ID.


// Задание 14
// Добавь возможность динамически менять лимит — например, 
// через `configChan <- 5`, `Throttler` подстраивается.


// Задание 15
// Добавь graceful shutdown: при `os.Interrupt` прекращай 
// приём новых задач, жди завершения активных.


// Задание 16
// Сделай декоратор `WithThrottling(fn func()) func()`, 
// который ограничивает количество одновременных вызовов.


// Задание 17
// Создай структуру `UserThrottler` с отдельным лимитом 
// на каждого пользователя (по userID, хранимым в `sync.Map`).


// Задание 18
// Добавь очередь задач: если лимит исчерпан, задача 
// попадает в буфер (канал), а не отменяется.


// Задание 19
// Сделай канал ошибок: если `Acquire(ctx)` прерван — логируй 
// в `errChan`, который читает главная горутина.


// Задание 20
// Имплементируй `TryAcquire() bool`, который не блокирует, 
// а сразу возвращает true/false — полезно для fast-fail.


