package main

// Задание 1
// Сделай `time.Ticker` с интервалом 200ms. Выполняй обработку задач 
// не чаще чем 5 раз в секунду.


// Задание 2
// Создай структуру `Limiter`, внутри которой `ticker *time.Ticker`. 
// Сделай метод `Wait()`.


// Задание 3
// Модифицируй предыдущую задачу: метод `Wait(ctx)` 
// должен завершаться, если контекст отменён.


// Задание 4
// Сделай лимитер на основе `chan struct{}`. В отдельной 
// горутине добавляй токены каждые 100ms (10 в секунду), максимум 5 токенов.


// Задание 5
// Создай worker pool, который перед обработкой каждой 
// задачи запрашивает токен у лимитера.


// Задание 6
// Добавь atomic-счётчик с количеством задач, обработанных 
// за последнюю секунду. Выводи каждую секунду.


// Задание 7
// Создай `rate limiter` для пользовательского API. Каждому 
// userID выдается отдельный лимитер, хранимый в `sync.Map`.


// Задание 8
// Реализуй интерфейс `Limiter` с методом `Wait(ctx context.Context) error`. 
// Сделай 2 реализации: `TickerLimiter`, `ChannelLimiter`.


// Задание 9
// Сделай структуру `Job{id int, userID string}`. Лимитируй 
// выполнение задач по userID: не более 2 в секунду на пользователя.


// Задание 10
// Добавь механизм очистки неиспользуемых лимитеров из `sync.Map` 
// (например, если не использовались более 1 мин).


// Задание 11
// Создай обёртку `LogLimiter`, которая логирует каждое ожидание 
// токена: start/end + задержка.


// Задание 12
// Добавь метрику: максимальная задержка на выдачу токена за 
// последние 10 секунд. Обновляется через atomic.


// Задание 13
// Преврати `ChannelLimiter` в middleware для HTTP: обрабатывает 
// не более N запросов/сек на endpoint.


// Задание 14
// Добавь graceful shutdown: по `os.Signal` (Ctrl+C) останавливается 
// генерация токенов и завершаются worker'ы.


// Задание 15
// Сравни на практике: `Ticker`, `ChannelLimiter`, `x/time/rate.Limiter`. 
// Выведи отклонения в интервалах выдачи.


// Задание 16
// Добавь в `Limiter` метод `TryAllow() bool`, который не блокирует, 
// а сразу говорит, можно ли обрабатывать.


// Задание 17
// Сделай лимитер с burst-режимом: 10 мгновенных задач, потом пауза 1 секунда. 
// Используй буферизированный канал.


// Задание 18
// Интегрируй limiter в fan-out/fan-in pipeline: обработка задач 
// ограничена 5 rps на каждого воркера.


// Задание 19
// Сделай структуру `MultiLimiter`, которая агрегирует несколько 
// лимитеров и разрешает выполнение, только если все согласны.


// Задание 20
// Реализуй лимитер, конфигурируемый в рантайме: можно менять `rps` 
// и `burst` через канал `configChan`.


