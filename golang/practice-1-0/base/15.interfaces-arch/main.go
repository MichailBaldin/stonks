package main

// Задание 1: Контракт сверху
// Условие:
// Определи интерфейс `Notifier` с методом `Notify(userID, message string) error` 
// в бизнес-слое (`domain/`)
// Создай структуру `EmailNotifier` в `infra/`, реализующую этот интерфейс.


// Задание 2: Внедрение зависимости через интерфейс
// Условие:
// Создай структуру `ReminderService` с полем `notifier Notifier`.
// В методе `SendReminder()` используй `notifier.Notify(...)`


// Задание 3: Мини-интерфейс
// Условие:
// Создай интерфейс `StringGetter` с методом `Get() string`
// Реализуй его на двух структурах: `EnvVarGetter`, `ConstGetter`.


// Задание 4: Порт + адаптер
// Условие:
// Создай интерфейс `Storage` с методом `Save(data string) error`
// Реализуй `FileStorage` (записывает в файл) и `MemoryStorage` (в слайс).


// Задание 5: Подмена реализаций
// Условие:
// Создай `Service` с полем `storage Storage`
// Проверь, что можешь передать `MemoryStorage`, `FileStorage`, 
// `MockStorage` — без изменения `Service`.


// Задание 6: Интерфейс внутри use-case
// Условие:
// В пакете `accounting` создай интерфейс `RateProvider`, 
// который предоставляет курсы валют.
// Реализуй `FixedRateProvider`, который возвращает фиксированный курс.


// Задание 7: Модуль, не знающий реализацию
// Условие:
// Создай `ReportGenerator`, принимающий интерфейс `DataFetcher`.
// Реализуй два типа данных: `SQLFetcher` и `CSVFetcher`.


// Задание 8: Компиляционная проверка реализации
// Условие:
// Добавь строку:
// var _ Storage = (*FileStorage)(nil)
// Проверь, что компиляция падает, если забыть реализовать метод `Save`.


// Задание 9: Срез интерфейсов
// Условие:
// Создай `[]Notifier`, содержащий `EmailNotifier`, `SmsNotifier`, `NullNotifier`.
// Итерируйся и вызывай `.Notify(...)` у каждого.


// Задание 10: Интерфейс в тестах
// Условие:
// Создай интерфейс `Sender`, и структуру `FakeSender`, 
// логирующую отправки в `[]string`.
// Передай её в `Service` для проверки поведения без настоящей отправки.

