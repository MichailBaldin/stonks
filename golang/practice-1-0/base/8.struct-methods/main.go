package main

// Структуры и методы

// Задание 1: Создание структуры
// Условие:
// Создай структуру `Movie` с полями `Title string`, `Duration int`.
// Создай экземпляр и выведи его поля.

// Задание 2: Передача структуры в функцию
// Условие:
// Напиши функцию `printUser(u User)`, которая принимает структуру `User`
// и печатает имя и возраст. Структура: `User{Name string; Age int}`.

// Задание 3: Передача по указателю
// Условие:
// Напиши функцию `addScore(g *Game, points int)`, которая увеличивает `Score`.
// Структура: `Game{Name string; Score int}`.

// Задание 4: Метод для структуры
// Условие:
// Определи метод `Status()` для структуры `Task`, возвращающий строку вида
// `"Task: <Name> (done: <true/false>)"`. Структура: `Task{Name string; Done bool}`.

// Задание 5: Метод с указателем
// Условие:
// Создай метод `Rename(newName string)` для структуры `Project` с рецептором `*Project`,
// чтобы менять название. Структура: `Project{Name string}`.

// Задание 6: Метод-цепочка
// Условие:
// Реализуй метод `Deposit(amount float64) *Account`, чтобы можно было вызывать цепочкой:
// acc.Deposit(100).SetOwner("Alice"). Структура: `Account{Owner string; Balance float64}`.

// Задание 7: Конструктор
// Условие:
// Создай функцию `NewSensor(id string, value float64) *Sensor`,
// которая возвращает указатель на структуру `Sensor{ID string; Value float64}`.

// Задание 8: Метод, использующий другие поля
// Условие:
// Добавь в структуру `Trip{Distance float64; Time float64}` метод `Speed() float64`,
// возвращающий среднюю скорость (Distance / Time).

// Задание 9: Метод сравнения
// Условие:
// Сделай метод `SameCity(other Airport) bool`, сравнивающий города двух аэропортов.
// Структура: `Airport{Code string; City string}`.

// Задание 10: Метод копирования
// Условие:
// Добавь метод `Clone() Product`, который возвращает копию структуры `Product{Name string; Price float64}`.

// =====================================================================
// Композиция структур

// Задание 1: Встраивание структуры
// Условие:
// Создай структуру `Location` с полем `City string`.
// Создай `Office`, встраивая `Location`.
// Проверь, что `Office{City: "Berlin"}` работает без дополнительного уровня доступа.

// Задание 2: Доступ к полю вложенной структуры
// Условие:
// Создай `Device` с полем `Model string`, и `User` со встроенным `Device`.
// Убедись, что `user.Model = "X100"` работает напрямую.

// Задание 3: Конфликт имён
// Условие:
// В структурах `BaseConfig` и `CustomConfig` добавь поле `Enabled bool`.
// Что произойдёт при `fmt.Println(cfg.Enabled)`, если `CustomConfig` встраивает `BaseConfig`?

// Задание 4: Метод встроенной структуры
// Условие:
// Пусть структура `Engine` имеет метод `Start()`.
// Если `Robot` встраивает `Engine`, можно ли вызвать `r.Start()`? Проверь.

// Задание 5: Переопределение метода
// Условие:
// У `BaseHandler` реализуй метод `Handle()`.
// В `ExtendedHandler`, встраивающем `BaseHandler`, реализуй свой `Handle()`.
// Что вызовется при `h.Handle()`?

// Задание 6: Расширение логики
// Условие:
// Создай структуру `Notifier` с методом `Notify(msg string)`.
// Встрой её в `AlarmSystem` и проверь, что `a.Notify("ALERT")` вызывает метод `Notifier`.

// Задание 7: Использование композиции вместо наследования
// Условие:
// Пусть `Reporter` имеет метод `Report() string`.
// Структура `JSONReporter` встраивает `Reporter` и переопределяет `Report` для возврата JSON.

// Задание 8: Множественное встраивание
// Условие:
// Создай `Trackable` с полем `Timestamp`, `Versioned` с полем `Version`,
// и встрой обе в структуру `Record`. Убедись, что доступ к обоим полям идёт напрямую.

// Задание 9: Вызов метода из вложенной структуры явно
// Условие:
// Пусть `System` встраивает `Logger`, и также имеет свой метод `Log()`.
// Как вызвать именно `Logger.Log()`? Пример: `s.Logger.Log("debug")`.

// Задание 10: Композиция и интерфейсы
// Условие:
// Если `type Runner interface { Run() }`, и `Module` реализует `Run()`,
// а `App` встраивает `Module` — реализует ли `App` интерфейс `Runner`? Проверь.

// =====================================================================
// Вложенность структур

// Задание 1: Структура внутри структуры
// Условие:
// Создай `Address{City string, Zip string}`
// И `User{Name string, Address Address}`
// Создай пользователя и выведи его город.

// Задание 2: Доступ к вложенным полям
// Условие:
// Создай `Company{Name string, CEO Person}`
// Выведи имя CEO: `company.CEO.Name`

// Задание 3: Модификация вложенного поля
// Условие:
// Измени `user.Address.City = "Moscow"`
// Убедись, что изменение отражается в выводе.

// Задание 4: Указатель на вложенную структуру
// Условие:
// В `User` вместо `Address`, используй `*Address`
// Инициализируй через `&Address{...}`
// Проверь доступ: `user.Address.City`

// Задание 5: Вложенность в 2+ уровня
// Условие:
// Создай `Company{CEO Person{Address}}`
// Инициализируй всё и выведи `company.CEO.Address.City`

// Задание 6: Вложенная структура как параметр
// Условие:
// Напиши функцию `printCity(u User)`,
// которая принимает `User` и печатает `u.Address.City`

// Задание 7: Метод на вложенной структуре
// Условие:
// Создай метод `Full()` на `Address`, возвращающий `"City Zip"`
// Вызови `user.Address.Full()` из `main()`

// Задание 8: Метод, обращающийся к вложенной структуре
// Условие:
// Добавь метод `City()` у `User`, который возвращает `u.Address.City`

// Задание 9: Передача вложенной структуры в функцию
// Условие:
// Напиши `printZip(a Address)`
// В `main()` передай `user.Address` напрямую

// Задание 10: Копирование структуры с вложенными значениями
// Условие:
// Создай `u2 := u`
// Измени `u2.Address.City`, выведи `u.Address.City`
// Вопрос:
// Изменилось ли поле у оригинала?
// *(→ зависит от значения или указателя: если `Address`,
// то копия; если `*Address`, то ссылаются на один объект)*

// =====================================================================
// Интерфейсы
// Задание 1: Простой интерфейс
// Условие:
// Создай интерфейс `Speaker` с методом `Speak() string`
// И структуру `Dog{Name string}`, реализующую его.
// Проверь, что `Dog` можно передать в `func saySomething(s Speaker)`.

// Задание 2: Неявная реализация
// Условие:
// Докажи, что в Go **не нужно** явно писать `implements`.
// Просто создай структуру, у которой есть нужный метод — и она реализует интерфейс.

// Задание 3: Интерфейс как параметр
// Условие:
// Создай функцию `Describe(s fmt.Stringer)`
// и передай в неё `time.Now()` и `bytes.Buffer`.

// Задание 4: Интерфейс с несколькими методами
// Условие:
// Создай интерфейс `Shape` с методами `Area() float64` и `Perimeter() float64`.
// Реализуй его для `Rectangle{Width, Height}`.

// Задание 5: Интерфейсная переменная
// Условие:
// Объяви переменную `var s Shape` и присвой ей `Rectangle{...}`.
// Вызови методы и проверь поведение.

// Задание 6: Type assertion
// Условие:
// Создай интерфейс `Animal`, присвой переменной `a Animal = Dog{Name: "Barky"}`
// Сделай `dog := a.(Dog)` и выведи имя.

// Задание 7: Type switch
// Условие:
// Реализуй функцию `printType(i interface{})`,
// которая через `switch v := i.(type)` выводит конкретный тип.

// Задание 8: Пустой интерфейс `interface{}`
// Условие:
// Напиши функцию `acceptAnything(val interface{})`
// Передай в неё строку, число и слайс.
// Выведи значения и их типы.

// Задание 9: nil-интерфейс
// Условие:
// Создай `var err error = nil`, затем `var e error = someNilPointer`
// Поясни, почему `e != nil`, хотя указатель nil.
// (*→ интерфейс содержит тип + значение, и `type != nil`*)

// Задание 10: Комбинирование интерфейсов
// Условие:
// Создай два интерфейса: `Reader` и `Writer`,
// затем интерфейс `ReadWriter`, объединяющий их.
// Реализуй для структуры `Buffer`.
//=====================================================

// ======================================
// Тренажёр: Структуры, встраивание, коллекции (v1)
// ======================================
// Формат как раньше: короткие условия, базовое API, без изысков.

// --- Блок A. База структур (литералы, zero value, сравнение) ---

// 1. Опиши структуру User{ID int; Name string}. Создай zero value и литерал, выведи поля.
// 2. Добавь метод String() для User, который печатает "ID:Name". Вызови через fmt.Println(u).
// 3. Сделай тип Address{City string; Street string}. Вложи Address в User как поле (композиция), выведи City.
// 4. Сравни два значения Address оператором ==. Объясни, почему User с полем-срезом так сравнить нельзя (закомментируй попытку).
// 5. Создай слайс []User из 3 элементов и измени Name у второго — проверь выводом.

// --- Блок B. Методы: значение vs указатель ---

// 6. Добавь к User метод Rename(new string) с value receiver. Вызови и проверь, изменился ли Name.
// 7. Переделай Rename на pointer receiver и повтори проверку.
// 8. Реализуй метод Clone() User, который возвращает копию со сменой Name (оригинал не меняется).
// 9. Сделай функцию NewUser(id int, name string) *User (конструктор) — верни указатель, проверь, что поля выставлены.
// 10. Для Address сделай метод Full() string = "City, Street". Вызови через u.Address.Full().

// --- Блок C. Встраивание (embedding) полей и метод-promotion ---

// 11. Создай тип Timestamps{CreatedAt int64; UpdatedAt int64}. Встрой его анонимно в User: Timestamps.
//     Доступ к полям через u.CreatedAt.
// 12. Добавь Timestamps метод Touch() — обновляет UpdatedAt. Вызови u.Touch() (через promotion).
// 13. Создай тип Named{Name string} и встрой в User: Named. Покажи конфликт имён полей (если уже есть Name).
// 14. Разреши конфликт: убери поле Name в User, оставь его во встраиваемом Named. Доступ к имени — u.Name.
// 15. Встрой *Address (указатель) в User: *Address. Проверь панику при обращении u.City без инициализации. Почини инициализацией.
// 16. Добавь к Address метод Move(city, street). Вызови u.Move(... ) через promotion.
// 17. Создай админов: тип Admin с встраиваемым User. Добавь метод IsAdmin() bool. Проверь доступ к полям User из Admin.
// 18. Сделай два уровня встраивания: SuperAdmin{Admin}, вызови метод Touch() (из Timestamps через User) на SuperAdmin.
// 19. Встрой sync.Mutex в тип SafeCounter{sync.Mutex; m map[string]int}. Покажи Lock/Unlock и инкремент по ключу.
// 20. Удали embedding Mutex и сделай именованное поле. Покажи, что теперь нужен s.Mutex.Lock() вместо promotion.

// --- Блок D. Коллекции структур (слайсы) ---

// 21. Создай []User и реализуй функции: AppendUser([]User, User) []User; IndexByID([]User, id) int.
// 22. Отфильтруй []User по предикату (Name != ""), используя "in-place filter": dst := users[:0].
// 23. Отсортируй []User по Name с помощью sort.Slice.
// 24. Реализуй Paginate(users []User, page, per int) []User — верни подотрезок с границами.
// 25. Сделай глубокое копирование []User (копии значений), измени копию и покажи независимость от оригинала.

// --- Блок E. Коллекции структур (мапы) ---

// 26. Построй индекс: map[int]*User по слайсу пользователей. Проверь, что изменения через указатель видны в исходном слайсе.
// 27. Реализуй MergeUsersByID(dst map[int]*User, src []User): добавляй отсутствующих, обновляй Name по совпавшим ID.
// 28. Инвертируй индекс имён: map[string][]int где ключ — Name, значение — список ID.
// 29. Реализуй DiffUsersByID(a, b map[int]*User]): верни списки added/removed/updated ID.
// 30. Реализуй безопасное чтение: GetUser(m map[int]*User, id int) (*User, bool), не создавая лишних записей.

// --- Блок F. Вложенные слайсы и мапы внутри структур ---

// 31. Тип Group{Name string; Members []User}. Добавь метод Add(u User) и RemoveByID(id int) с сохранением порядка.
// 32. Тип Org{Name string; Teams map[string]*Group}. Функция AddToTeam(org *Org, team string, u User) с инициализацией map и Members.
// 33. Тип Catalog{ByCity map[string][]*User}. Добавь пользователя по городу, инициализируя при первом добавлении.
// 34. Тип KVStore{Buckets map[string]map[string]string}. Реализуй Upsert(bucket, key, val string).
// 35. Покажи aliasing: два Group ссылаются на один и тот же слайс Members. Измени один — увидь изменения в другом. Почини глубокой копией.

// --- Блок G. JSON-теги и сериализация ---

// 36. Добавь json-теги в User: id, name. Сериализуй []User в JSON и обратно.
// 37. Убери поле Address из JSON (omitempty + "-" для внутренних). Проверь результат.
// 38. Тип Profile{User; Skills []string}. Сериализуй и проверь, что поля User промотируются в JSON.
// 39. Создай map[int]User и сериализуй — поймай конвертацию ключей в строки. Прочитай обратно в map[string]User или в []pair.

// --- Блок H. Конструкторы и валидация ---

// 40. Напиши NewAddress(city, street string) (*Address, error) с простой валидацией (не пустые строки).
// 41. Сделай NewUserWithAddress(id int, name string, addr *Address) (*User, error) — собирает валидный объект.
// 42. Добавь метод Validate() error для User (проверка Name != ""). Вызови перед добавлением в коллекцию.
// 43. Тип Registry{byID map[int]*User}. Реализуй Register(u *User) error — ошибка при дубликате ID, иначе сохранить.
// 44. Реализуй FindByCity(reg *Registry, city string) []User — по вложенному адресу (*Address).

// --- Блок I. Копирование, мутабельность, границы ---

// 45. Покажи разницу копии значения и указателя: u2 := u; p := &u; измени p.Name — проверь u2.Name.
// 46. В Group реализуй DeepClone() Group: новая копия слайса и значений.
// 47. Сделай SafeSlice(users []User) []User, который возвращает копию для чтения "без утечки" внутреннего слайса наружу.
// 48. Реализуй метод TrimTo(n int) для Group — усечь Members до n безопасно (границы, не паниковать).
// 49. Реализуй ReplaceMember(g *Group, i int, u User) error — безопасная замена по индексу с проверкой границ.
// 50. Реализуй Snapshot(reg *Registry) map[int]User — вернуть "замороженную" копию (значения, не указатели).
