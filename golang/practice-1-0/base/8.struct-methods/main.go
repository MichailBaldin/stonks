package main

// Структуры и методы

// Задание 1: Создание структуры
// Условие:
// Создай структуру `Movie` с полями `Title string`, `Duration int`.
// Создай экземпляр и выведи его поля.

// Задание 2: Передача структуры в функцию
// Условие:
// Напиши функцию `printUser(u User)`, которая принимает структуру `User`
// и печатает имя и возраст. Структура: `User{Name string; Age int}`.

// Задание 3: Передача по указателю
// Условие:
// Напиши функцию `addScore(g *Game, points int)`, которая увеличивает `Score`.
// Структура: `Game{Name string; Score int}`.

// Задание 4: Метод для структуры
// Условие:
// Определи метод `Status()` для структуры `Task`, возвращающий строку вида
// `"Task: <Name> (done: <true/false>)"`. Структура: `Task{Name string; Done bool}`.

// Задание 5: Метод с указателем
// Условие:
// Создай метод `Rename(newName string)` для структуры `Project` с рецептором `*Project`,
// чтобы менять название. Структура: `Project{Name string}`.

// Задание 6: Метод-цепочка
// Условие:
// Реализуй метод `Deposit(amount float64) *Account`, чтобы можно было вызывать цепочкой:
// acc.Deposit(100).SetOwner("Alice"). Структура: `Account{Owner string; Balance float64}`.

// Задание 7: Конструктор
// Условие:
// Создай функцию `NewSensor(id string, value float64) *Sensor`,
// которая возвращает указатель на структуру `Sensor{ID string; Value float64}`.

// Задание 8: Метод, использующий другие поля
// Условие:
// Добавь в структуру `Trip{Distance float64; Time float64}` метод `Speed() float64`,
// возвращающий среднюю скорость (Distance / Time).

// Задание 9: Метод сравнения
// Условие:
// Сделай метод `SameCity(other Airport) bool`, сравнивающий города двух аэропортов.
// Структура: `Airport{Code string; City string}`.

// Задание 10: Метод копирования
// Условие:
// Добавь метод `Clone() Product`, который возвращает копию структуры `Product{Name string; Price float64}`.

// =====================================================================
// Композиция структур

// Задание 1: Встраивание структуры
// Условие:
// Создай структуру `Location` с полем `City string`.
// Создай `Office`, встраивая `Location`.
// Проверь, что `Office{City: "Berlin"}` работает без дополнительного уровня доступа.

// Задание 2: Доступ к полю вложенной структуры
// Условие:
// Создай `Device` с полем `Model string`, и `User` со встроенным `Device`.
// Убедись, что `user.Model = "X100"` работает напрямую.

// Задание 3: Конфликт имён
// Условие:
// В структурах `BaseConfig` и `CustomConfig` добавь поле `Enabled bool`.
// Что произойдёт при `fmt.Println(cfg.Enabled)`, если `CustomConfig` встраивает `BaseConfig`?

// Задание 4: Метод встроенной структуры
// Условие:
// Пусть структура `Engine` имеет метод `Start()`.
// Если `Robot` встраивает `Engine`, можно ли вызвать `r.Start()`? Проверь.

// Задание 5: Переопределение метода
// Условие:
// У `BaseHandler` реализуй метод `Handle()`.
// В `ExtendedHandler`, встраивающем `BaseHandler`, реализуй свой `Handle()`.
// Что вызовется при `h.Handle()`?

// Задание 6: Расширение логики
// Условие:
// Создай структуру `Notifier` с методом `Notify(msg string)`.
// Встрой её в `AlarmSystem` и проверь, что `a.Notify("ALERT")` вызывает метод `Notifier`.

// Задание 7: Использование композиции вместо наследования
// Условие:
// Пусть `Reporter` имеет метод `Report() string`.
// Структура `JSONReporter` встраивает `Reporter` и переопределяет `Report` для возврата JSON.

// Задание 8: Множественное встраивание
// Условие:
// Создай `Trackable` с полем `Timestamp`, `Versioned` с полем `Version`,
// и встрой обе в структуру `Record`. Убедись, что доступ к обоим полям идёт напрямую.

// Задание 9: Вызов метода из вложенной структуры явно
// Условие:
// Пусть `System` встраивает `Logger`, и также имеет свой метод `Log()`.
// Как вызвать именно `Logger.Log()`? Пример: `s.Logger.Log("debug")`.

// Задание 10: Композиция и интерфейсы
// Условие:
// Если `type Runner interface { Run() }`, и `Module` реализует `Run()`,
// а `App` встраивает `Module` — реализует ли `App` интерфейс `Runner`? Проверь.

// =====================================================================
// Вложенность структур

// Задание 1: Структура внутри структуры
// Условие:
// Создай `Address{City string, Zip string}`
// И `User{Name string, Address Address}`
// Создай пользователя и выведи его город.

// Задание 2: Доступ к вложенным полям
// Условие:
// Создай `Company{Name string, CEO Person}`
// Выведи имя CEO: `company.CEO.Name`

// Задание 3: Модификация вложенного поля
// Условие:
// Измени `user.Address.City = "Moscow"`
// Убедись, что изменение отражается в выводе.

// Задание 4: Указатель на вложенную структуру
// Условие:
// В `User` вместо `Address`, используй `*Address`
// Инициализируй через `&Address{...}`
// Проверь доступ: `user.Address.City`

// Задание 5: Вложенность в 2+ уровня
// Условие:
// Создай `Company{CEO Person{Address}}`
// Инициализируй всё и выведи `company.CEO.Address.City`

// Задание 6: Вложенная структура как параметр
// Условие:
// Напиши функцию `printCity(u User)`,
// которая принимает `User` и печатает `u.Address.City`

// Задание 7: Метод на вложенной структуре
// Условие:
// Создай метод `Full()` на `Address`, возвращающий `"City Zip"`
// Вызови `user.Address.Full()` из `main()`

// Задание 8: Метод, обращающийся к вложенной структуре
// Условие:
// Добавь метод `City()` у `User`, который возвращает `u.Address.City`

// Задание 9: Передача вложенной структуры в функцию
// Условие:
// Напиши `printZip(a Address)`
// В `main()` передай `user.Address` напрямую

// Задание 10: Копирование структуры с вложенными значениями
// Условие:
// Создай `u2 := u`
// Измени `u2.Address.City`, выведи `u.Address.City`
// Вопрос:
// Изменилось ли поле у оригинала?
// *(→ зависит от значения или указателя: если `Address`,
// то копия; если `*Address`, то ссылаются на один объект)*

// =====================================================================
// Интерфейсы
// Задание 1: Простой интерфейс
// Условие:
// Создай интерфейс `Speaker` с методом `Speak() string`
// И структуру `Dog{Name string}`, реализующую его.
// Проверь, что `Dog` можно передать в `func saySomething(s Speaker)`.

// Задание 2: Неявная реализация
// Условие:
// Докажи, что в Go **не нужно** явно писать `implements`.
// Просто создай структуру, у которой есть нужный метод — и она реализует интерфейс.

// Задание 3: Интерфейс как параметр
// Условие:
// Создай функцию `Describe(s fmt.Stringer)`
// и передай в неё `time.Now()` и `bytes.Buffer`.

// Задание 4: Интерфейс с несколькими методами
// Условие:
// Создай интерфейс `Shape` с методами `Area() float64` и `Perimeter() float64`.
// Реализуй его для `Rectangle{Width, Height}`.

// Задание 5: Интерфейсная переменная
// Условие:
// Объяви переменную `var s Shape` и присвой ей `Rectangle{...}`.
// Вызови методы и проверь поведение.

// Задание 6: Type assertion
// Условие:
// Создай интерфейс `Animal`, присвой переменной `a Animal = Dog{Name: "Barky"}`
// Сделай `dog := a.(Dog)` и выведи имя.

// Задание 7: Type switch
// Условие:
// Реализуй функцию `printType(i interface{})`,
// которая через `switch v := i.(type)` выводит конкретный тип.

// Задание 8: Пустой интерфейс `interface{}`
// Условие:
// Напиши функцию `acceptAnything(val interface{})`
// Передай в неё строку, число и слайс.
// Выведи значения и их типы.

// Задание 9: nil-интерфейс
// Условие:
// Создай `var err error = nil`, затем `var e error = someNilPointer`
// Поясни, почему `e != nil`, хотя указатель nil.
// (*→ интерфейс содержит тип + значение, и `type != nil`*)

// Задание 10: Комбинирование интерфейсов
// Условие:
// Создай два интерфейса: `Reader` и `Writer`,
// затем интерфейс `ReadWriter`, объединяющий их.
// Реализуй для структуры `Buffer`.
