package main

// Задание 1
// Создай `var x int32`, инкрементируй его из 5 горутин с `atomic.AddInt32`.


// Задание 2
// Сделай 1000 инкрементов счётчика через `atomic.AddInt64`, проверь результат.


// Задание 3
// Создай структуру `AtomicCounter` с методом `Inc()`, использующим `atomic`.


// Задание 4
// Добавь метод `Value()` для `AtomicCounter`, использующий `atomic.LoadInt64`.


// Задание 5
// Сделай конкурентный `flag` (`int32`), который одна горутина ставит в `1`, остальные проверяют через `CompareAndSwap`.


// Задание 6
// Симулируй спинлок: цикл `for !atomic.CompareAndSwapInt32(&x, 0, 1) {}` — только одна горутина проходит.


// Задание 7
// Переделай счётчик из прошлой задачи `sync.Mutex` на `sync/atomic`. Сравни производительность.


// Задание 8
// Реализуй структуру `AtomicFlag` с методами `Set()`, `Clear()`, `IsSet()` — с `atomic.StoreInt32` и `LoadInt32`.


// Задание 9
// Создай `atomic.Value` и передай туда структуру `Config{name string}`. Во второй горутине прочитай и выведи.


// Задание 10
// Создай глобальный `atomic.Value` для хранения конфига. При обновлении — все воркеры начинают использовать новое значение.


// Задание 11
// Интегрируй `context.Context` + `atomic.Value`: воркер использует `Load()` конфига, пока не `ctx.Done()`.


// Задание 12
// Реализуй `SafeCounter` с интерфейсом `Incrementer`, используя атомарный счётчик. Интерфейс должен иметь `Inc()`, `Get()`.


// Задание 13
// Сравни поведение: `counter++` без защиты → с `mutex` → с `atomic`.


// Задание 14
// Создай `uint32` счётчик запросов. Используй `atomic.AddUint32` в HTTP-обработчике.


// Задание 15
// Создай воркер, который атомарно переключает `mode int32` между 0 и 1 каждые 100ms. Остальные читают `Load()`.


// Задание 16
// Проверь гонку: атомарное чтение одного поля и обычное чтение второго — Go race detector покажет ошибку?


// Задание 17
// Создай `Toggle()` функцию, которая атомарно переключает значение `0 → 1` или `1 → 0`.


// Задание 18
// Реализуй структуру `SessionStore`, где каждую секунду обновляется `atomic.Value` с данными сессий.


// Задание 19
// Сделай структуру `Stats`, где атомарно обновляются `Hits`, `Errors`. Покрой `atomic` все поля.


// Задание 20
// Проведи тест на производительность `atomic.AddInt64` vs `mutex` на 10M итераций — замерь время.

