# 3. HTTP Клиент

## Создание запросов

### Простые запросы (функции-хелперы)
```go
package main

import (
    "fmt"
    "io"
    "net/http"
    "strings"
)

func main() {
    // GET запрос
    resp, err := http.Get("https://httpbin.org/get")
    if err != nil {
        panic(err)
    }
    defer resp.Body.Close()
    
    body, _ := io.ReadAll(resp.Body)
    fmt.Printf("GET ответ: %s\n\n", string(body))
    
    // POST запрос с данными
    data := strings.NewReader(`{"name": "John", "age": 30}`)
    resp2, err := http.Post("https://httpbin.org/post", "application/json", data)
    if err != nil {
        panic(err)
    }
    defer resp2.Body.Close()
    
    body2, _ := io.ReadAll(resp2.Body)
    fmt.Printf("POST ответ: %s\n", string(body2))
}
```

### Создание кастомных запросов
```go
package main

import (
    "bytes"
    "fmt"
    "io"
    "net/http"
)

func main() {
    // Создаем запрос вручную
    jsonData := []byte(`{"message": "Hello from Go!"}`)
    
    req, err := http.NewRequest("PUT", "https://httpbin.org/put", bytes.NewBuffer(jsonData))
    if err != nil {
        panic(err)
    }
    
    // Устанавливаем заголовки
    req.Header.Set("Content-Type", "application/json")
    req.Header.Set("Authorization", "Bearer token123")
    req.Header.Set("User-Agent", "MyGoApp/1.0")
    
    // Выполняем запрос
    client := &http.Client{}
    resp, err := client.Do(req)
    if err != nil {
        panic(err)
    }
    defer resp.Body.Close()
    
    body, _ := io.ReadAll(resp.Body)
    fmt.Printf("Статус: %s\n", resp.Status)
    fmt.Printf("Ответ: %s\n", string(body))
}
```

## Настройка клиента

### Клиент с тайм-аутами
```go
package main

import (
    "fmt"
    "net/http"
    "time"
)

func main() {
    // Настраиваем клиент
    client := &http.Client{
        Timeout: 10 * time.Second, // Общий тайм-аут запроса
        Transport: &http.Transport{
            DialTimeout:           5 * time.Second,  // Тайм-аут подключения
            ResponseHeaderTimeout: 5 * time.Second,  // Тайм-аут получения заголовков
            IdleConnTimeout:       30 * time.Second, // Тайм-аут неактивного соединения
        },
    }
    
    resp, err := client.Get("https://httpbin.org/delay/2") // Задержка 2 сек
    if err != nil {
        fmt.Printf("Ошибка: %v\n", err)
        return
    }
    defer resp.Body.Close()
    
    fmt.Printf("Запрос выполнен успешно: %s\n", resp.Status)
}
```

### Клиент с повторными использованиями
```go
package main

import (
    "fmt"
    "io"
    "net/http"
    "time"
)

// Создаем глобальный клиент (рекомендуется)
var httpClient = &http.Client{
    Timeout: 30 * time.Second,
}

func getUser(userID string) (string, error) {
    url := fmt.Sprintf("https://jsonplaceholder.typicode.com/users/%s", userID)
    
    resp, err := httpClient.Get(url)
    if err != nil {
        return "", err
    }
    defer resp.Body.Close()
    
    if resp.StatusCode != http.StatusOK {
        return "", fmt.Errorf("получен статус: %s", resp.Status)
    }
    
    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return "", err
    }
    
    return string(body), nil
}

func main() {
    // Используем один клиент для множества запросов
    for i := 1; i <= 3; i++ {
        user, err := getUser(fmt.Sprintf("%d", i))
        if err != nil {
            fmt.Printf("Ошибка для пользователя %d: %v\n", i, err)
            continue
        }
        fmt.Printf("Пользователь %d: %s\n\n", i, user)
    }
}
```

## Обработка ответов

### Проверка статус кодов
```go
package main

import (
    "fmt"
    "io"
    "net/http"
)

func main() {
    resp, err := http.Get("https://httpbin.org/status/404")
    if err != nil {
        panic(err)
    }
    defer resp.Body.Close()
    
    // Проверяем статус код
    switch resp.StatusCode {
    case http.StatusOK:
        fmt.Println("Успешно!")
    case http.StatusNotFound:
        fmt.Println("Ресурс не найден")
    case http.StatusInternalServerError:
        fmt.Println("Ошибка сервера")
    default:
        fmt.Printf("Неожиданный статус: %d - %s\n", resp.StatusCode, resp.Status)
    }
    
    // Читаем заголовки
    fmt.Printf("Content-Type: %s\n", resp.Header.Get("Content-Type"))
    fmt.Printf("Content-Length: %s\n", resp.Header.Get("Content-Length"))
    
    // Читаем тело ответа
    body, _ := io.ReadAll(resp.Body)
    fmt.Printf("Тело ответа: %s\n", string(body))
}
```

### Обработка различных типов ответов
```go
package main

import (
    "encoding/json"
    "fmt"
    "io"
    "net/http"
)

type User struct {
    ID    int    `json:"id"`
    Name  string `json:"name"`
    Email string `json:"email"`
}

func main() {
    resp, err := http.Get("https://jsonplaceholder.typicode.com/users/1")
    if err != nil {
        panic(err)
    }
    defer resp.Body.Close()
    
    // Проверяем Content-Type
    contentType := resp.Header.Get("Content-Type")
    fmt.Printf("Content-Type: %s\n", contentType)
    
    if resp.StatusCode != http.StatusOK {
        fmt.Printf("Ошибка: %s\n", resp.Status)
        return
    }
    
    // Способ 1: Читаем как строку
    body, err := io.ReadAll(resp.Body)
    if err != nil {
        panic(err)
    }
    fmt.Printf("Сырые данные: %s\n\n", string(body))
    
    // Способ 2: Парсим JSON напрямую из resp.Body
    // Для этого нужно сделать новый запрос, так как Body уже прочитан
    resp2, _ := http.Get("https://jsonplaceholder.typicode.com/users/1")
    defer resp2.Body.Close()
    
    var user User
    if err := json.NewDecoder(resp2.Body).Decode(&user); err != nil {
        panic(err)
    }
    
    fmt.Printf("Распарсенный пользователь: %+v\n", user)
}
```

## Полный пример практичного HTTP клиента

```go
package main

import (
    "bytes"
    "encoding/json"
    "fmt"
    "net/http"
    "time"
)

type APIClient struct {
    baseURL string
    client  *http.Client
}

func NewAPIClient(baseURL string) *APIClient {
    return &APIClient{
        baseURL: baseURL,
        client: &http.Client{
            Timeout: 30 * time.Second,
        },
    }
}

func (c *APIClient) GetUser(userID int) (map[string]interface{}, error) {
    url := fmt.Sprintf("%s/users/%d", c.baseURL, userID)
    
    resp, err := c.client.Get(url)
    if err != nil {
        return nil, fmt.Errorf("запрос не выполнен: %w", err)
    }
    defer resp.Body.Close()
    
    if resp.StatusCode != http.StatusOK {
        return nil, fmt.Errorf("получен статус %d", resp.StatusCode)
    }
    
    var result map[string]interface{}
    if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
        return nil, fmt.Errorf("ошибка парсинга JSON: %w", err)
    }
    
    return result, nil
}

func (c *APIClient) CreatePost(title, body string) error {
    url := fmt.Sprintf("%s/posts", c.baseURL)
    
    payload := map[string]interface{}{
        "title":  title,
        "body":   body,
        "userId": 1,
    }
    
    jsonData, _ := json.Marshal(payload)
    
    req, err := http.NewRequest("POST", url, bytes.NewBuffer(jsonData))
    if err != nil {
        return err
    }
    
    req.Header.Set("Content-Type", "application/json")
    
    resp, err := c.client.Do(req)
    if err != nil {
        return err
    }
    defer resp.Body.Close()
    
    if resp.StatusCode != http.StatusCreated {
        return fmt.Errorf("ожидался статус 201, получен %d", resp.StatusCode)
    }
    
    return nil
}

func main() {
    client := NewAPIClient("https://jsonplaceholder.typicode.com")
    
    // Получаем пользователя
    user, err := client.GetUser(1)
    if err != nil {
        fmt.Printf("Ошибка получения пользователя: %v\n", err)
    } else {
        fmt.Printf("Пользователь: %v\n", user["name"])
    }
    
    // Создаем пост
    err = client.CreatePost("Мой пост", "Содержимое поста")
    if err != nil {
        fmt.Printf("Ошибка создания поста: %v\n", err)
    } else {
        fmt.Println("Пост создан успешно!")
    }
}
```

---