# 6. Повседневные задачи API

## REST API паттерны

### Полноценный CRUD API

```go
package main

import (
    "encoding/json"
    "fmt"
    "net/http"
    "strconv"
    "strings"
    "time"
)

type Task struct {
    ID          int       `json:"id"`
    Title       string    `json:"title"`
    Description string    `json:"description"`
    Completed   bool      `json:"completed"`
    CreatedAt   time.Time `json:"created_at"`
    UpdatedAt   time.Time `json:"updated_at"`
}

type CreateTaskRequest struct {
    Title       string `json:"title"`
    Description string `json:"description"`
}

type UpdateTaskRequest struct {
    Title       *string `json:"title,omitempty"`
    Description *string `json:"description,omitempty"`
    Completed   *bool   `json:"completed,omitempty"`
}

type APIResponse struct {
    Success bool        `json:"success"`
    Data    interface{} `json:"data,omitempty"`
    Error   string      `json:"error,omitempty"`
    Meta    interface{} `json:"meta,omitempty"`
}

// "База данных"
var tasks = make(map[int]Task)
var nextID = 1

// Хелперы для ответов
func sendJSON(w http.ResponseWriter, status int, data interface{}) {
    w.Header().Set("Content-Type", "application/json")
    w.WriteHeader(status)
    json.NewEncoder(w).Encode(data)
}

func sendError(w http.ResponseWriter, status int, message string) {
    sendJSON(w, status, APIResponse{Success: false, Error: message})
}

func sendSuccess(w http.ResponseWriter, status int, data interface{}) {
    sendJSON(w, status, APIResponse{Success: true, Data: data})
}

// REST endpoints
func tasksHandler(w http.ResponseWriter, r *http.Request) {
    switch r.Method {
    case http.MethodGet:
        getAllTasks(w, r)
    case http.MethodPost:
        createTask(w, r)
    default:
        sendError(w, http.StatusMethodNotAllowed, "Метод не поддерживается")
    }
}

func taskHandler(w http.ResponseWriter, r *http.Request) {
    // Извлекаем ID из URL /tasks/{id}
    idStr := strings.TrimPrefix(r.URL.Path, "/tasks/")
    if idStr == "" {
        sendError(w, http.StatusBadRequest, "ID задачи не указан")
        return
    }
    
    id, err := strconv.Atoi(idStr)
    if err != nil {
        sendError(w, http.StatusBadRequest, "Неверный формат ID")
        return
    }
    
    switch r.Method {
    case http.MethodGet:
        getTask(w, r, id)
    case http.MethodPut:
        updateTask(w, r, id)
    case http.MethodDelete:
        deleteTask(w, r, id)
    default:
        sendError(w, http.StatusMethodNotAllowed, "Метод не поддерживается")
    }
}

// GET /tasks - получить все задачи
func getAllTasks(w http.ResponseWriter, r *http.Request) {
    // Поддержка query параметров
    completed := r.URL.Query().Get("completed")
    
    var result []Task
    for _, task := range tasks {
        // Фильтрация по completed
        if completed != "" {
            isCompleted, _ := strconv.ParseBool(completed)
            if task.Completed != isCompleted {
                continue
            }
        }
        result = append(result, task)
    }
    
    // Мета-информация
    meta := map[string]interface{}{
        "total": len(result),
        "completed": len(filterTasks(true)),
        "pending": len(filterTasks(false)),
    }
    
    response := APIResponse{
        Success: true,
        Data:    result,
        Meta:    meta,
    }
    
    sendJSON(w, http.StatusOK, response)
}

// POST /tasks - создать задачу
func createTask(w http.ResponseWriter, r *http.Request) {
    var req CreateTaskRequest
    if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
        sendError(w, http.StatusBadRequest, "Ошибка парсинга JSON")
        return
    }
    
    // Валидация
    if req.Title == "" {
        sendError(w, http.StatusBadRequest, "Поле title обязательно")
        return
    }
    
    // Создаем задачу
    task := Task{
        ID:          nextID,
        Title:       req.Title,
        Description: req.Description,
        Completed:   false,
        CreatedAt:   time.Now(),
        UpdatedAt:   time.Now(),
    }
    
    tasks[nextID] = task
    nextID++
    
    sendSuccess(w, http.StatusCreated, task)
}

// GET /tasks/{id} - получить задачу
func getTask(w http.ResponseWriter, r *http.Request, id int) {
    task, exists := tasks[id]
    if !exists {
        sendError(w, http.StatusNotFound, "Задача не найдена")
        return
    }
    
    sendSuccess(w, http.StatusOK, task)
}

// PUT /tasks/{id} - обновить задачу
func updateTask(w http.ResponseWriter, r *http.Request, id int) {
    task, exists := tasks[id]
    if !exists {
        sendError(w, http.StatusNotFound, "Задача не найдена")
        return
    }
    
    var req UpdateTaskRequest
    if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
        sendError(w, http.StatusBadRequest, "Ошибка парсинга JSON")
        return
    }
    
    // Частичное обновление
    if req.Title != nil {
        task.Title = *req.Title
    }
    if req.Description != nil {
        task.Description = *req.Description
    }
    if req.Completed != nil {
        task.Completed = *req.Completed
    }
    
    task.UpdatedAt = time.Now()
    tasks[id] = task
    
    sendSuccess(w, http.StatusOK, task)
}

// DELETE /tasks/{id} - удалить задачу
func deleteTask(w http.ResponseWriter, r *http.Request, id int) {
    _, exists := tasks[id]
    if !exists {
        sendError(w, http.StatusNotFound, "Задача не найдена")
        return
    }
    
    delete(tasks, id)
    sendSuccess(w, http.StatusOK, map[string]string{"message": "Задача удалена"})
}

func filterTasks(completed bool) []Task {
    var result []Task
    for _, task := range tasks {
        if task.Completed == completed {
            result = append(result, task)
        }
    }
    return result
}

func main() {
    // Добавляем тестовые данные
    tasks[1] = Task{
        ID: 1, Title: "Изучить Go", Description: "Пройти курс по HTTP",
        Completed: false, CreatedAt: time.Now(), UpdatedAt: time.Now(),
    }
    tasks[2] = Task{
        ID: 2, Title: "Написать API", Description: "Создать REST API",
        Completed: true, CreatedAt: time.Now(), UpdatedAt: time.Now(),
    }
    nextID = 3
    
    http.HandleFunc("/tasks", tasksHandler)
    http.HandleFunc("/tasks/", taskHandler)
    
    fmt.Println("REST API сервер на :8080")
    fmt.Println("Доступные endpoints:")
    fmt.Println("GET    /tasks        - все задачи")
    fmt.Println("GET    /tasks?completed=true - только завершенные")
    fmt.Println("POST   /tasks        - создать задачу")
    fmt.Println("GET    /tasks/{id}   - получить задачу")
    fmt.Println("PUT    /tasks/{id}   - обновить задачу")
    fmt.Println("DELETE /tasks/{id}   - удалить задачу")
    
    http.ListenAndServe(":8080", nil)
}
```

## Аутентификация

### JWT аутентификация

```go
package main

import (
    "crypto/hmac"
    "crypto/sha256"
    "encoding/base64"
    "encoding/json"
    "fmt"
    "net/http"
    "strings"
    "time"
)

// Простая реализация JWT (в продакшене используйте библиотеку)
type JWTClaims struct {
    UserID int    `json:"user_id"`
    Email  string `json:"email"`
    Exp    int64  `json:"exp"`
}

type User struct {
    ID       int    `json:"id"`
    Email    string `json:"email"`
    Password string `json:"-"` // Не возвращаем в JSON
}

type LoginRequest struct {
    Email    string `json:"email"`
    Password string `json:"password"`
}

type AuthResponse struct {
    Token string `json:"token"`
    User  User   `json:"user"`
}

const jwtSecret = "your-secret-key"

// "База данных" пользователей
var users = map[string]User{
    "admin@example.com": {ID: 1, Email: "admin@example.com", Password: "password123"},
    "user@example.com":  {ID: 2, Email: "user@example.com", Password: "password456"},
}

// Простая реализация JWT
func createJWT(claims JWTClaims) (string, error) {
    // Header
    header := map[string]string{"alg": "HS256", "typ": "JWT"}
    headerJSON, _ := json.Marshal(header)
    headerEncoded := base64.URLEncoding.EncodeToString(headerJSON)
    
    // Payload
    claimsJSON, _ := json.Marshal(claims)
    claimsEncoded := base64.URLEncoding.EncodeToString(claimsJSON)
    
    // Signature
    message := headerEncoded + "." + claimsEncoded
    signature := createSignature(message, jwtSecret)
    
    return message + "." + signature, nil
}

func createSignature(message, secret string) string {
    h := hmac.New(sha256.New, []byte(secret))
    h.Write([]byte(message))
    return base64.URLEncoding.EncodeToString(h.Sum(nil))
}

func validateJWT(tokenString string) (*JWTClaims, error) {
    parts := strings.Split(tokenString, ".")
    if len(parts) != 3 {
        return nil, fmt.Errorf("неверный формат токена")
    }
    
    // Проверяем подпись
    message := parts[0] + "." + parts[1]
    expectedSignature := createSignature(message, jwtSecret)
    if parts[2] != expectedSignature {
        return nil, fmt.Errorf("неверная подпись")
    }
    
    // Декодируем claims
    claimsJSON, err := base64.URLEncoding.DecodeString(parts[1])
    if err != nil {
        return nil, fmt.Errorf("ошибка декодирования claims")
    }
    
    var claims JWTClaims
    if err := json.Unmarshal(claimsJSON, &claims); err != nil {
        return nil, fmt.Errorf("ошибка парсинга claims")
    }
    
    // Проверяем срок действия
    if time.Now().Unix() > claims.Exp {
        return nil, fmt.Errorf("токен истек")
    }
    
    return &claims, nil
}

// Middleware для аутентификации
func authMiddleware(next http.HandlerFunc) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        authHeader := r.Header.Get("Authorization")
        if authHeader == "" {
            http.Error(w, "Требуется авторизация", http.StatusUnauthorized)
            return
        }
        
        if !strings.HasPrefix(authHeader, "Bearer ") {
            http.Error(w, "Неверный формат токена", http.StatusUnauthorized)
            return
        }
        
        tokenString := strings.TrimPrefix(authHeader, "Bearer ")
        claims, err := validateJWT(tokenString)
        if err != nil {
            http.Error(w, "Неверный токен: "+err.Error(), http.StatusUnauthorized)
            return
        }
        
        // Добавляем информацию о пользователе в контекст
        // В реальном приложении используйте context.WithValue
        r.Header.Set("X-User-ID", fmt.Sprintf("%d", claims.UserID))
        r.Header.Set("X-User-Email", claims.Email)
        
        next(w, r)
    }
}

// Handlers
func loginHandler(w http.ResponseWriter, r *http.Request) {
    if r.Method != http.MethodPost {
        http.Error(w, "Используйте POST", http.StatusMethodNotAllowed)
        return
    }
    
    var req LoginRequest
    if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
        http.Error(w, "Ошибка парсинга JSON", http.StatusBadRequest)
        return
    }
    
    // Проверяем пользователя
    user, exists := users[req.Email]
    if !exists || user.Password != req.Password {
        http.Error(w, "Неверные учетные данные", http.StatusUnauthorized)
        return
    }
    
    // Создаем токен
    claims := JWTClaims{
        UserID: user.ID,
        Email:  user.Email,
        Exp:    time.Now().Add(24 * time.Hour).Unix(), // 24 часа
    }
    
    token, err := createJWT(claims)
    if err != nil {
        http.Error(w, "Ошибка создания токена", http.StatusInternalServerError)
        return
    }
    
    // Возвращаем токен и информацию о пользователе
    response := AuthResponse{
        Token: token,
        User:  user,
    }
    
    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(response)
}

func profileHandler(w http.ResponseWriter, r *http.Request) {
    userID := r.Header.Get("X-User-ID")
    userEmail := r.Header.Get("X-User-Email")
    
    response := map[string]interface{}{
        "message":    "Доступ к защищенному ресурсу",
        "user_id":    userID,
        "user_email": userEmail,
        "timestamp":  time.Now(),
    }
    
    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(response)
}

func publicHandler(w http.ResponseWriter, r *http.Request) {
    response := map[string]interface{}{
        "message": "Это публичный endpoint",
        "time":    time.Now(),
    }
    
    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(response)
}

func main() {
    http.HandleFunc("/login", loginHandler)
    http.HandleFunc("/profile", authMiddleware(profileHandler))
    http.HandleFunc("/public", publicHandler)
    
    fmt.Println("Сервер с аутентификацией на :8080")
    fmt.Println("\nДоступные endpoints:")
    fmt.Println("POST /login   - войти (email: admin@example.com, password: password123)")
    fmt.Println("GET  /profile - защищенный ресурс (нужен Bearer токен)")
    fmt.Println("GET  /public  - публичный ресурс")
    fmt.Println("\nПример использования:")
    fmt.Println("1. Войти: curl -X POST -d '{\"email\":\"admin@example.com\",\"password\":\"password123\"}' http://localhost:8080/login")
    fmt.Println("2. Использовать токен: curl -H 'Authorization: Bearer YOUR_TOKEN' http://localhost:8080/profile")
    
    http.ListenAndServe(":8080", nil)
}
```

## Работа с внешними API

### HTTP клиент для интеграций

```go
package main

import (
    "bytes"
    "encoding/json"
    "fmt"
    "io"
    "net/http"
    "time"
)

// Структуры для JSONPlaceholder API
type Post struct {
    ID     int    `json:"id"`
    UserID int    `json:"userId"`
    Title  string `json:"title"`
    Body   string `json:"body"`
}

type User struct {
    ID       int    `json:"id"`
    Name     string `json:"name"`
    Username string `json:"username"`
    Email    string `json:"email"`
}

// Клиент для внешнего API
type ExternalAPIClient struct {
    baseURL    string
    httpClient *http.Client
    apiKey     string
}

func NewExternalAPIClient(baseURL, apiKey string) *ExternalAPIClient {
    return &ExternalAPIClient{
        baseURL: baseURL,
        apiKey:  apiKey,
        httpClient: &http.Client{
            Timeout: 30 * time.Second,
            Transport: &http.Transport{
                MaxIdleConns:       10,
                IdleConnTimeout:    90 * time.Second,
                DisableCompression: false,
            },
        },
    }
}

func (c *ExternalAPIClient) doRequest(method, endpoint string, body interface{}) (*http.Response, error) {
    url := c.baseURL + endpoint
    
    var reqBody io.Reader
    if body != nil {
        jsonData, err := json.Marshal(body)
        if err != nil {
            return nil, fmt.Errorf("ошибка сериализации: %w", err)
        }
        reqBody = bytes.NewBuffer(jsonData)
    }
    
    req, err := http.NewRequest(method, url, reqBody)
    if err != nil {
        return nil, fmt.Errorf("ошибка создания запроса: %w", err)
    }
    
    // Устанавливаем заголовки
    req.Header.Set("Content-Type", "application/json")
    req.Header.Set("User-Agent", "MyApp/1.0")
    if c.apiKey != "" {
        req.Header.Set("Authorization", "Bearer "+c.apiKey)
    }
    
    // Выполняем запрос с retry логикой
    return c.doRequestWithRetry(req, 3)
}

func (c *ExternalAPIClient) doRequestWithRetry(req *http.Request, maxRetries int) (*http.Response, error) {
    var resp *http.Response
    var err error
    
    for i := 0; i <= maxRetries; i++ {
        resp, err = c.httpClient.Do(req)
        
        // Если запрос успешен или это не серверная ошибка - возвращаем
        if err == nil && resp.StatusCode < 500 {
            return resp, nil
        }
        
        // Если есть ответ, закрываем тело
        if resp != nil {
            resp.Body.Close()
        }
        
        // Если это последняя попытка - не ждем
        if i == maxRetries {
            break
        }
        
        // Ждем перед повторной попыткой (exponential backoff)
        waitTime := time.Duration(i+1) * time.Second
        fmt.Printf("Попытка %d неуспешна, ждем %v...\n", i+1, waitTime)
        time.Sleep(waitTime)
    }
    
    return resp, err
}

// Методы для работы с API
func (c *ExternalAPIClient) GetPosts() ([]Post, error) {
    resp, err := c.doRequest("GET", "/posts", nil)
    if err != nil {
        return nil, err
    }
    defer resp.Body.Close()
    
    if resp.StatusCode != http.StatusOK {
        body, _ := io.ReadAll(resp.Body)
        return nil, fmt.Errorf("API вернул статус %d: %s", resp.StatusCode, string(body))
    }
    
    var posts []Post
    if err := json.NewDecoder(resp.Body).Decode(&posts); err != nil {
        return nil, fmt.Errorf("ошибка парсинга ответа: %w", err)
    }
    
    return posts, nil
}

func (c *ExternalAPIClient) GetPost(id int) (*Post, error) {
    endpoint := fmt.Sprintf("/posts/%d", id)
    resp, err := c.doRequest("GET", endpoint, nil)
    if err != nil {
        return nil, err
    }
    defer resp.Body.Close()
    
    if resp.StatusCode == http.StatusNotFound {
        return nil, fmt.Errorf("пост с ID %d не найден", id)
    }
    
    if resp.StatusCode != http.StatusOK {
        return nil, fmt.Errorf("API вернул статус %d", resp.StatusCode)
    }
    
    var post Post
    if err := json.NewDecoder(resp.Body).Decode(&post); err != nil {
        return nil, fmt.Errorf("ошибка парсинга ответа: %w", err)
    }
    
    return &post, nil
}

func (c *ExternalAPIClient) CreatePost(post Post) (*Post, error) {
    resp, err := c.doRequest("POST", "/posts", post)
    if err != nil {
        return nil, err
    }
    defer resp.Body.Close()
    
    if resp.StatusCode != http.StatusCreated {
        body, _ := io.ReadAll(resp.Body)
        return nil, fmt.Errorf("ошибка создания поста: %s", string(body))
    }
    
    var createdPost Post
    if err := json.NewDecoder(resp.Body).Decode(&createdPost); err != nil {
        return nil, fmt.Errorf("ошибка парсинга ответа: %w", err)
    }
    
    return &createdPost, nil
}

func (c *ExternalAPIClient) GetUser(id int) (*User, error) {
    endpoint := fmt.Sprintf("/users/%d", id)
    resp, err := c.doRequest("GET", endpoint, nil)
    if err != nil {
        return nil, err
    }
    defer resp.Body.Close()
    
    if resp.StatusCode != http.StatusOK {
        return nil, fmt.Errorf("пользователь с ID %d не найден", id)
    }
    
    var user User
    if err := json.NewDecoder(resp.Body).Decode(&user); err != nil {
        return nil, fmt.Errorf("ошибка парсинга пользователя: %w", err)
    }
    
    return &user, nil
}

// Агрегированные методы
func (c *ExternalAPIClient) GetPostWithAuthor(postID int) (Post, User, error) {
    // Получаем пост
    post, err := c.GetPost(postID)
    if err != nil {
        return Post{}, User{}, fmt.Errorf("ошибка получения поста: %w", err)
    }
    
    // Получаем автора
    user, err := c.GetUser(post.UserID)
    if err != nil {
        return *post, User{}, fmt.Errorf("ошибка получения автора: %w", err)
    }
    
    return *post, *user, nil
}

// HTTP handlers для нашего API
func postsProxyHandler(client *ExternalAPIClient) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        posts, err := client.GetPosts()
        if err != nil {
            http.Error(w, "Ошибка получения постов: "+err.Error(), http.StatusInternalServerError)
            return
        }
        
        // Берем только первые 5 постов
        if len(posts) > 5 {
            posts = posts[:5]
        }
        
        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]interface{}{
            "success": true,
            "data":    posts,
            "total":   len(posts),
        })
    }
}

func postWithAuthorHandler(client *ExternalAPIClient) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        // Извлекаем ID из URL
        idStr := r.URL.Query().Get("id")
        if idStr == "" {
            http.Error(w, "Параметр id обязателен", http.StatusBadRequest)
            return
        }
        
        var id int
        if _, err := fmt.Sscanf(idStr, "%d", &id); err != nil {
            http.Error(w, "Неверный формат ID", http.StatusBadRequest)
            return
        }
        
        post, author, err := client.GetPostWithAuthor(id)
        if err != nil {
            http.Error(w, err.Error(), http.StatusInternalServerError)
            return
        }
        
        result := map[string]interface{}{
            "post":   post,
            "author": author,
        }
        
        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]interface{}{
            "success": true,
            "data":    result,
        })
    }
}

func main() {
    // Создаем клиент для внешнего API
    client := NewExternalAPIClient("https://jsonplaceholder.typicode.com", "")
    
    // Настраиваем роуты
    http.HandleFunc("/posts", postsProxyHandler(client))
    http.HandleFunc("/post-with-author", postWithAuthorHandler(client))
    
    // Демонстрация работы с API
    fmt.Println("Демонстрация работы с внешним API...")
    
    // Получаем пост с автором
    post, author, err := client.GetPostWithAuthor(1)
    if err != nil {
        fmt.Printf("Ошибка: %v\n", err)
    } else {
        fmt.Printf("Пост: %s\n", post.Title)
        fmt.Printf("Автор: %s (%s)\n\n", author.Name, author.Email)
    }
    
    // Создаем новый пост
    newPost := Post{
        UserID: 1,
        Title:  "Мой новый пост",
        Body:   "Содержимое нового поста",
    }
    
    createdPost, err := client.CreatePost(newPost)
    if err != nil {
        fmt.Printf("Ошибка создания поста: %v\n", err)
    } else {
        fmt.Printf("Создан пост с ID: %d\n\n", createdPost.ID)
    }
    
    fmt.Println("HTTP сервер на :8080")
    fmt.Println("GET /posts - получить первые 5 постов")
    fmt.Println("GET /post-with-author?id=1 - получить пост с автором")
    
    http.ListenAndServe(":8080", nil)
}
```

---

## Заключение

Поздравляю! Мы прошли весь путь от TCP основ до построения полноценных API. Теперь ты знаешь:

✅ **Основы HTTP в Go** - сервер, клиент, базовые концепции  
✅ **HTTP Сервер** - обработчики, роутинг, параметры  
✅ **HTTP Клиент** - запросы, настройки, обработка ответов  
✅ **Работа с данными** - JSON, формы, файлы, заголовки  
✅ **Практические аспекты** - middleware, ошибки, логирование, тестирование  
✅ **Повседневные задачи** - REST API, аутентификация, внешние API  

**Ключевые моменты для собеседования:**
- Всегда закрывай `resp.Body.Close()`
- Используй контекст для тайм-аутов и отмены
- Middleware для общей логики (логирование, авторизация)
- Структурированная обработка ошибок с правильными HTTP кодами
- Тестирование через `httptest`

**Следующие шаги:**
- Изучи популярные роутеры (gorilla/mux, gin, echo)
- Освой работу с базами данных в HTTP handlers
- Изучи gRPC как альтернативу REST
- Практикуйся с реальными API интеграциями