# 4. Работа с данными

## JSON encoding/decoding

### На стороне сервера - принимаем и отдаем JSON

```go
package main

import (
    "encoding/json"
    "fmt"
    "net/http"
)

type User struct {
    ID    int    `json:"id"`
    Name  string `json:"name"`
    Email string `json:"email"`
}

type CreateUserRequest struct {
    Name  string `json:"name"`
    Email string `json:"email"`
}

type Response struct {
    Success bool        `json:"success"`
    Data    interface{} `json:"data,omitempty"`
    Error   string      `json:"error,omitempty"`
}

func usersHandler(w http.ResponseWriter, r *http.Request) {
    w.Header().Set("Content-Type", "application/json")
    
    switch r.Method {
    case http.MethodGet:
        // Отдаем список пользователей
        users := []User{
            {ID: 1, Name: "Иван", Email: "ivan@example.com"},
            {ID: 2, Name: "Мария", Email: "maria@example.com"},
        }
        
        response := Response{Success: true, Data: users}
        json.NewEncoder(w).Encode(response)
        
    case http.MethodPost:
        // Принимаем нового пользователя
        var req CreateUserRequest
        
        if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
            w.WriteHeader(http.StatusBadRequest)
            response := Response{Success: false, Error: "Неверный JSON"}
            json.NewEncoder(w).Encode(response)
            return
        }
        
        // Создаем пользователя
        user := User{
            ID:    3,
            Name:  req.Name,
            Email: req.Email,
        }
        
        w.WriteHeader(http.StatusCreated)
        response := Response{Success: true, Data: user}
        json.NewEncoder(w).Encode(response)
        
    default:
        w.WriteHeader(http.StatusMethodNotAllowed)
        response := Response{Success: false, Error: "Метод не поддерживается"}
        json.NewEncoder(w).Encode(response)
    }
}

func main() {
    http.HandleFunc("/users", usersHandler)
    fmt.Println("Сервер на :8080")
    fmt.Println("GET  http://localhost:8080/users")
    fmt.Println("POST http://localhost:8080/users")
    http.ListenAndServe(":8080", nil)
}
```

### На стороне клиента - отправляем и читаем JSON

```go
package main

import (
    "bytes"
    "encoding/json"
    "fmt"
    "net/http"
)

type User struct {
    ID    int    `json:"id"`
    Name  string `json:"name"`
    Email string `json:"email"`
}

type CreateUserRequest struct {
    Name  string `json:"name"`
    Email string `json:"email"`
}

type Response struct {
    Success bool        `json:"success"`
    Data    interface{} `json:"data"`
    Error   string      `json:"error"`
}

func getUsers() ([]User, error) {
    resp, err := http.Get("http://localhost:8080/users")
    if err != nil {
        return nil, err
    }
    defer resp.Body.Close()
    
    var response Response
    if err := json.NewDecoder(resp.Body).Decode(&response); err != nil {
        return nil, err
    }
    
    if !response.Success {
        return nil, fmt.Errorf("ошибка API: %s", response.Error)
    }
    
    // Преобразуем interface{} в []User
    usersData, _ := json.Marshal(response.Data)
    var users []User
    json.Unmarshal(usersData, &users)
    
    return users, nil
}

func createUser(name, email string) (*User, error) {
    // Подготавливаем данные
    reqData := CreateUserRequest{Name: name, Email: email}
    jsonData, err := json.Marshal(reqData)
    if err != nil {
        return nil, err
    }
    
    // Отправляем POST запрос
    resp, err := http.Post("http://localhost:8080/users", "application/json", bytes.NewBuffer(jsonData))
    if err != nil {
        return nil, err
    }
    defer resp.Body.Close()
    
    var response Response
    if err := json.NewDecoder(resp.Body).Decode(&response); err != nil {
        return nil, err
    }
    
    if !response.Success {
        return nil, fmt.Errorf("ошибка API: %s", response.Error)
    }
    
    // Преобразуем interface{} в User
    userData, _ := json.Marshal(response.Data)
    var user User
    json.Unmarshal(userData, &user)
    
    return &user, nil
}

func main() {
    // Получаем пользователей
    users, err := getUsers()
    if err != nil {
        fmt.Printf("Ошибка получения пользователей: %v\n", err)
    } else {
        fmt.Printf("Пользователи: %+v\n", users)
    }
    
    // Создаем пользователя
    user, err := createUser("Петр", "petr@example.com")
    if err != nil {
        fmt.Printf("Ошибка создания пользователя: %v\n", err)
    } else {
        fmt.Printf("Создан пользователь: %+v\n", user)
    }
}
```

## Работа с формами

### Обработка form data на сервере

```go
package main

import (
    "fmt"
    "net/http"
)

func formHandler(w http.ResponseWriter, r *http.Request) {
    switch r.Method {
    case http.MethodGet:
        // Показываем форму
        html := `
        <form method="POST" action="/form">
            <p>Имя: <input type="text" name="name" required></p>
            <p>Email: <input type="email" name="email" required></p>
            <p>Возраст: <input type="number" name="age"></p>
            <p>Хобби:
                <input type="checkbox" name="hobbies" value="программирование"> Программирование
                <input type="checkbox" name="hobbies" value="чтение"> Чтение
                <input type="checkbox" name="hobbies" value="спорт"> Спорт
            </p>
            <p><button type="submit">Отправить</button></p>
        </form>`
        
        w.Header().Set("Content-Type", "text/html; charset=utf-8")
        fmt.Fprint(w, html)
        
    case http.MethodPost:
        // Обрабатываем форму
        
        // Парсим form data (важно вызвать!)
        err := r.ParseForm()
        if err != nil {
            http.Error(w, "Ошибка парсинга формы", http.StatusBadRequest)
            return
        }
        
        // Получаем значения
        name := r.FormValue("name")           // Одно значение
        email := r.FormValue("email")
        age := r.FormValue("age")
        hobbies := r.Form["hobbies"]          // Множественные значения
        
        // Отвечаем
        w.Header().Set("Content-Type", "text/html; charset=utf-8")
        fmt.Fprintf(w, `
        <h2>Получены данные:</h2>
        <p>Имя: %s</p>
        <p>Email: %s</p>
        <p>Возраст: %s</p>
        <p>Хобби: %v</p>
        <a href="/form">Назад к форме</a>
        `, name, email, age, hobbies)
    }
}

func main() {
    http.HandleFunc("/form", formHandler)
    fmt.Println("Сервер на http://localhost:8080/form")
    http.ListenAndServe(":8080", nil)
}
```

### Отправка form data клиентом

```go
package main

import (
    "fmt"
    "io"
    "net/http"
    "net/url"
    "strings"
)

func sendFormData() {
    // Способ 1: Через url.Values
    data := url.Values{}
    data.Set("name", "Алексей")
    data.Set("email", "alexey@example.com")
    data.Set("age", "28")
    data.Add("hobbies", "программирование")
    data.Add("hobbies", "чтение")
    
    resp, err := http.Post("http://localhost:8080/form", 
        "application/x-www-form-urlencoded", 
        strings.NewReader(data.Encode()))
    
    if err != nil {
        panic(err)
    }
    defer resp.Body.Close()
    
    body, _ := io.ReadAll(resp.Body)
    fmt.Printf("Ответ сервера:\n%s\n", string(body))
}

func sendFormDataManual() {
    // Способ 2: Вручную формируем строку
    formData := "name=Мария&email=maria@example.com&age=25&hobbies=спорт&hobbies=чтение"
    
    resp, err := http.Post("http://localhost:8080/form",
        "application/x-www-form-urlencoded",
        strings.NewReader(formData))
    
    if err != nil {
        panic(err)
    }
    defer resp.Body.Close()
    
    body, _ := io.ReadAll(resp.Body)
    fmt.Printf("Ответ сервера:\n%s\n", string(body))
}

func main() {
    fmt.Println("Отправляем form data...")
    sendFormData()
    
    fmt.Println("\nОтправляем form data вручную...")
    sendFormDataManual()
}
```

## Загрузка файлов

### Сервер - прием файлов

```go
package main

import (
    "fmt"
    "io"
    "net/http"
    "os"
    "path/filepath"
)

func uploadHandler(w http.ResponseWriter, r *http.Request) {
    switch r.Method {
    case http.MethodGet:
        // Показываем форму загрузки
        html := `
        <form method="POST" enctype="multipart/form-data" action="/upload">
            <p>Выберите файл: <input type="file" name="file" required></p>
            <p>Описание: <input type="text" name="description"></p>
            <p><button type="submit">Загрузить</button></p>
        </form>`
        
        w.Header().Set("Content-Type", "text/html; charset=utf-8")
        fmt.Fprint(w, html)
        
    case http.MethodPost:
        // Парсим multipart form (важно указать максимальный размер)
        err := r.ParseMultipartForm(10 << 20) // 10 MB
        if err != nil {
            http.Error(w, "Файл слишком большой", http.StatusBadRequest)
            return
        }
        
        // Получаем файл
        file, header, err := r.FormFile("file")
        if err != nil {
            http.Error(w, "Ошибка получения файла", http.StatusBadRequest)
            return
        }
        defer file.Close()
        
        // Получаем обычные поля формы
        description := r.FormValue("description")
        
        // Создаем файл на диске
        filename := filepath.Join("uploads", header.Filename)
        os.MkdirAll("uploads", 0755) // Создаем папку если не существует
        
        dst, err := os.Create(filename)
        if err != nil {
            http.Error(w, "Ошибка создания файла", http.StatusInternalServerError)
            return
        }
        defer dst.Close()
        
        // Копируем содержимое
        _, err = io.Copy(dst, file)
        if err != nil {
            http.Error(w, "Ошибка сохранения файла", http.StatusInternalServerError)
            return
        }
        
        fmt.Fprintf(w, "Файл '%s' загружен успешно!\nОписание: %s\nРазмер: %d байт", 
            header.Filename, description, header.Size)
    }
}

func main() {
    http.HandleFunc("/upload", uploadHandler)
    fmt.Println("Сервер на http://localhost:8080/upload")
    http.ListenAndServe(":8080", nil)
}
```

## Работа с заголовками

### Чтение заголовков запроса

```go
func headersHandler(w http.ResponseWriter, r *http.Request) {
    fmt.Fprintf(w, "Метод: %s\n", r.Method)
    fmt.Fprintf(w, "URL: %s\n", r.URL.String())
    fmt.Fprintf(w, "Протокол: %s\n\n", r.Proto)
    
    // Важные заголовки
    fmt.Fprintf(w, "User-Agent: %s\n", r.Header.Get("User-Agent"))
    fmt.Fprintf(w, "Content-Type: %s\n", r.Header.Get("Content-Type"))
    fmt.Fprintf(w, "Authorization: %s\n", r.Header.Get("Authorization"))
    fmt.Fprintf(w, "Accept: %s\n", r.Header.Get("Accept"))
    
    // Все заголовки
    fmt.Fprintf(w, "\nВсе заголовки:\n")
    for name, values := range r.Header {
        for _, value := range values {
            fmt.Fprintf(w, "%s: %s\n", name, value)
        }
    }
}
```

### Установка заголовков ответа

```go
func responseHeadersHandler(w http.ResponseWriter, r *http.Request) {
    // Устанавливаем заголовки ответа
    w.Header().Set("Content-Type", "application/json; charset=utf-8")
    w.Header().Set("Cache-Control", "no-cache")
    w.Header().Set("X-Custom-Header", "MyValue")
    
    // Множественные значения
    w.Header().Add("Set-Cookie", "session=abc123; Path=/")
    w.Header().Add("Set-Cookie", "lang=ru; Path=/")
    
    // Устанавливаем статус код (должно быть после заголовков, но до записи данных)
    w.WriteHeader(http.StatusOK)
    
    // Отправляем данные
    fmt.Fprintf(w, `{"message": "Заголовки установлены", "status": "success"}`)
}
```

---