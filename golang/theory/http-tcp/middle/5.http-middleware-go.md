# 5. Практические аспекты

## Middleware

Middleware - это функции, которые выполняются между получением запроса и отправкой ответа. Они позволяют добавлять общую логику (логирование, аутентификация, CORS).

### Простой middleware

```go
package main

import (
    "fmt"
    "log"
    "net/http"
    "time"
)

// Middleware для логирования
func loggingMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        start := time.Now()
        
        // Выполняем следующий обработчик
        next.ServeHTTP(w, r)
        
        // Логируем после выполнения
        log.Printf("%s %s %v", r.Method, r.URL.Path, time.Since(start))
    })
}

// Middleware для CORS
func corsMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        w.Header().Set("Access-Control-Allow-Origin", "*")
        w.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
        w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization")
        
        // Обрабатываем preflight запросы
        if r.Method == "OPTIONS" {
            w.WriteHeader(http.StatusOK)
            return
        }
        
        next.ServeHTTP(w, r)
    })
}

// Middleware для аутентификации
func authMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        token := r.Header.Get("Authorization")
        
        if token == "" {
            http.Error(w, "Требуется авторизация", http.StatusUnauthorized)
            return
        }
        
        if token != "Bearer secret-token" {
            http.Error(w, "Неверный токен", http.StatusForbidden)
            return
        }
        
        next.ServeHTTP(w, r)
    })
}

func homeHandler(w http.ResponseWriter, r *http.Request) {
    fmt.Fprintf(w, "Добро пожаловать на главную!")
}

func protectedHandler(w http.ResponseWriter, r *http.Request) {
    fmt.Fprintf(w, "Секретная информация!")
}

func main() {
    mux := http.NewServeMux()
    
    // Обычный handler с middleware
    mux.Handle("/", loggingMiddleware(corsMiddleware(http.HandlerFunc(homeHandler))))
    
    // Защищенный handler с цепочкой middleware
    protectedChain := loggingMiddleware(corsMiddleware(authMiddleware(http.HandlerFunc(protectedHandler))))
    mux.Handle("/protected", protectedChain)
    
    fmt.Println("Сервер на :8080")
    fmt.Println("GET http://localhost:8080/")
    fmt.Println("GET http://localhost:8080/protected (нужен заголовок Authorization: Bearer secret-token)")
    
    http.ListenAndServe(":8080", mux)
}
```

### Middleware с контекстом

```go
package main

import (
    "context"
    "fmt"
    "net/http"
)

type contextKey string

const userIDKey contextKey = "userID"

// Middleware для извлечения пользователя из токена
func userMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        token := r.Header.Get("Authorization")
        
        // Простая логика "аутентификации"
        var userID string
        switch token {
        case "Bearer user1":
            userID = "1"
        case "Bearer user2":
            userID = "2"
        default:
            http.Error(w, "Неверный токен", http.StatusUnauthorized)
            return
        }
        
        // Добавляем пользователя в контекст
        ctx := context.WithValue(r.Context(), userIDKey, userID)
        next.ServeHTTP(w, r.WithContext(ctx))
    })
}

func profileHandler(w http.ResponseWriter, r *http.Request) {
    // Извлекаем пользователя из контекста
    userID := r.Context().Value(userIDKey).(string)
    fmt.Fprintf(w, "Профиль пользователя ID: %s", userID)
}

func main() {
    mux := http.NewServeMux()
    mux.Handle("/profile", userMiddleware(http.HandlerFunc(profileHandler)))
    
    fmt.Println("Сервер на :8080")
    fmt.Println("GET http://localhost:8080/profile")
    fmt.Println("Используйте заголовок: Authorization: Bearer user1 или Bearer user2")
    
    http.ListenAndServe(":8080", mux)
}
```

## Обработка ошибок

### Структурированная обработка ошибок

```go
package main

import (
    "encoding/json"
    "fmt"
    "net/http"
    "strconv"
)

type APIError struct {
    Code    int    `json:"code"`
    Message string `json:"message"`
    Details string `json:"details,omitempty"`
}

func (e APIError) Error() string {
    return e.Message
}

// Хелпер для отправки JSON ошибок
func sendError(w http.ResponseWriter, err APIError) {
    w.Header().Set("Content-Type", "application/json")
    w.WriteHeader(err.Code)
    json.NewEncoder(w).Encode(err)
}

// Хелпер для отправки JSON ответов
func sendJSON(w http.ResponseWriter, data interface{}) {
    w.Header().Set("Content-Type", "application/json")
    w.WriteHeader(http.StatusOK)
    json.NewEncoder(w).Encode(data)
}

type User struct {
    ID   int    `json:"id"`
    Name string `json:"name"`
}

// "База данных" пользователей
var users = map[int]User{
    1: {ID: 1, Name: "Иван"},
    2: {ID: 2, Name: "Мария"},
}

func getUserHandler(w http.ResponseWriter, r *http.Request) {
    // Извлекаем ID из URL
    idStr := r.URL.Path[len("/users/"):]
    if idStr == "" {
        sendError(w, APIError{
            Code:    http.StatusBadRequest,
            Message: "ID пользователя не указан",
            Details: "Используйте /users/{id}",
        })
        return
    }
    
    // Парсим ID
    id, err := strconv.Atoi(idStr)
    if err != nil {
        sendError(w, APIError{
            Code:    http.StatusBadRequest,
            Message: "Неверный формат ID",
            Details: "ID должен быть числом",
        })
        return
    }
    
    // Проверяем существование пользователя
    user, exists := users[id]
    if !exists {
        sendError(w, APIError{
            Code:    http.StatusNotFound,
            Message: "Пользователь не найден",
            Details: fmt.Sprintf("Пользователь с ID %d не существует", id),
        })
        return
    }
    
    // Возвращаем пользователя
    sendJSON(w, user)
}

func createUserHandler(w http.ResponseWriter, r *http.Request) {
    if r.Method != http.MethodPost {
        sendError(w, APIError{
            Code:    http.StatusMethodNotAllowed,
            Message: "Метод не поддерживается",
            Details: "Используйте POST",
        })
        return
    }
    
    var user User
    if err := json.NewDecoder(r.Body).Decode(&user); err != nil {
        sendError(w, APIError{
            Code:    http.StatusBadRequest,
            Message: "Ошибка парсинга JSON",
            Details: err.Error(),
        })
        return
    }
    
    // Валидация
    if user.Name == "" {
        sendError(w, APIError{
            Code:    http.StatusBadRequest,
            Message: "Поле name обязательно",
        })
        return
    }
    
    // Генерируем ID и сохраняем
    user.ID = len(users) + 1
    users[user.ID] = user
    
    w.WriteHeader(http.StatusCreated)
    sendJSON(w, user)
}

func main() {
    http.HandleFunc("/users/", getUserHandler)
    http.HandleFunc("/users", createUserHandler)
    
    fmt.Println("Сервер на :8080")
    fmt.Println("GET  http://localhost:8080/users/1")
    fmt.Println("GET  http://localhost:8080/users/999 (ошибка)")
    fmt.Println("POST http://localhost:8080/users")
    
    http.ListenAndServe(":8080", nil)
}
```

## Логирование

### Структурированное логирование

```go
package main

import (
    "encoding/json"
    "fmt"
    "log"
    "net/http"
    "os"
    "time"
)

// Структура для логов
type LogEntry struct {
    Timestamp string `json:"timestamp"`
    Method    string `json:"method"`
    URL       string `json:"url"`
    Status    int    `json:"status"`
    Duration  string `json:"duration"`
    UserAgent string `json:"user_agent"`
    IP        string `json:"ip"`
}

// Wrapper для ResponseWriter для захвата статуса
type responseWriter struct {
    http.ResponseWriter
    status int
}

func (rw *responseWriter) WriteHeader(code int) {
    rw.status = code
    rw.ResponseWriter.WriteHeader(code)
}

func (rw *responseWriter) Write(b []byte) (int, error) {
    if rw.status == 0 {
        rw.status = 200
    }
    return rw.ResponseWriter.Write(b)
}

// Логгер
type Logger struct {
    *log.Logger
}

func NewLogger() *Logger {
    return &Logger{
        Logger: log.New(os.Stdout, "", 0),
    }
}

func (l *Logger) LogRequest(entry LogEntry) {
    // JSON формат
    jsonData, _ := json.Marshal(entry)
    l.Println(string(jsonData))
    
    // Читаемый формат
    // l.Printf("%s %s %d %s - %s\n", 
    //     entry.Method, entry.URL, entry.Status, entry.Duration, entry.IP)
}

func (l *Logger) LogError(msg string, err error) {
    errorLog := map[string]interface{}{
        "timestamp": time.Now().Format(time.RFC3339),
        "level":     "ERROR",
        "message":   msg,
        "error":     err.Error(),
    }
    jsonData, _ := json.Marshal(errorLog)
    l.Println(string(jsonData))
}

func (l *Logger) LogInfo(msg string, data map[string]interface{}) {
    infoLog := map[string]interface{}{
        "timestamp": time.Now().Format(time.RFC3339),
        "level":     "INFO",
        "message":   msg,
    }
    
    for k, v := range data {
        infoLog[k] = v
    }
    
    jsonData, _ := json.Marshal(infoLog)
    l.Println(string(jsonData))
}

var logger = NewLogger()

// Middleware для логирования запросов
func loggingMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        start := time.Now()
        
        // Оборачиваем ResponseWriter
        rw := &responseWriter{ResponseWriter: w}
        
        // Выполняем handler
        next.ServeHTTP(rw, r)
        
        // Логируем запрос
        entry := LogEntry{
            Timestamp: start.Format(time.RFC3339),
            Method:    r.Method,
            URL:       r.URL.String(),
            Status:    rw.status,
            Duration:  time.Since(start).String(),
            UserAgent: r.Header.Get("User-Agent"),
            IP:        r.RemoteAddr,
        }
        
        logger.LogRequest(entry)
    })
}

func homeHandler(w http.ResponseWriter, r *http.Request) {
    logger.LogInfo("Обработка главной страницы", map[string]interface{}{
        "user_ip": r.RemoteAddr,
    })
    
    fmt.Fprintf(w, "Добро пожаловать!")
}

func errorHandler(w http.ResponseWriter, r *http.Request) {
    // Симулируем ошибку
    err := fmt.Errorf("что-то пошло не так")
    logger.LogError("Ошибка в обработчике", err)
    
    http.Error(w, "Внутренняя ошибка сервера", http.StatusInternalServerError)
}

func main() {
    mux := http.NewServeMux()
    
    // Добавляем middleware ко всем handlers
    mux.Handle("/", loggingMiddleware(http.HandlerFunc(homeHandler)))
    mux.Handle("/error", loggingMiddleware(http.HandlerFunc(errorHandler)))
    
    logger.LogInfo("Сервер запущен", map[string]interface{}{
        "port": "8080",
    })
    
    fmt.Println("Сервер на :8080")
    http.ListenAndServe(":8080", mux)
}
```

## Тестирование HTTP

### Тестирование handlers

```go
// main.go
package main

import (
    "encoding/json"
    "fmt"
    "net/http"
    "strconv"
    "strings"
)

type User struct {
    ID   int    `json:"id"`
    Name string `json:"name"`
}

var users = map[int]User{
    1: {ID: 1, Name: "Иван"},
    2: {ID: 2, Name: "Мария"},
}

func getUserHandler(w http.ResponseWriter, r *http.Request) {
    if r.Method != http.MethodGet {
        http.Error(w, "Метод не поддерживается", http.StatusMethodNotAllowed)
        return
    }
    
    // Извлекаем ID
    path := strings.TrimPrefix(r.URL.Path, "/users/")
    id, err := strconv.Atoi(path)
    if err != nil {
        http.Error(w, "Неверный ID", http.StatusBadRequest)
        return
    }
    
    user, exists := users[id]
    if !exists {
        http.Error(w, "Пользователь не найден", http.StatusNotFound)
        return
    }
    
    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(user)
}

func createUserHandler(w http.ResponseWriter, r *http.Request) {
    if r.Method != http.MethodPost {
        http.Error(w, "Метод не поддерживается", http.StatusMethodNotAllowed)
        return
    }
    
    var user User
    if err := json.NewDecoder(r.Body).Decode(&user); err != nil {
        http.Error(w, "Ошибка парсинга JSON", http.StatusBadRequest)
        return
    }
    
    if user.Name == "" {
        http.Error(w, "Имя обязательно", http.StatusBadRequest)
        return
    }
    
    user.ID = len(users) + 1
    users[user.ID] = user
    
    w.Header().Set("Content-Type", "application/json")
    w.WriteHeader(http.StatusCreated)
    json.NewEncoder(w).Encode(user)
}

func main() {
    http.HandleFunc("/users/", getUserHandler)
    http.HandleFunc("/users", createUserHandler)
    
    fmt.Println("Сервер на :8080")
    http.ListenAndServe(":8080", nil)
}
```

```go
// main_test.go
package main

import (
    "bytes"
    "encoding/json"
    "net/http"
    "net/http/httptest"
    "testing"
)

func TestGetUserHandler(t *testing.T) {
    tests := []struct {
        name           string
        url            string
        expectedStatus int
        expectedUser   *User
    }{
        {
            name:           "Существующий пользователь",
            url:            "/users/1",
            expectedStatus: http.StatusOK,
            expectedUser:   &User{ID: 1, Name: "Иван"},
        },
        {
            name:           "Несуществующий пользователь",
            url:            "/users/999",
            expectedStatus: http.StatusNotFound,
            expectedUser:   nil,
        },
        {
            name:           "Неверный ID",
            url:            "/users/abc",
            expectedStatus: http.StatusBadRequest,
            expectedUser:   nil,
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            // Создаем запрос
            req := httptest.NewRequest(http.MethodGet, tt.url, nil)
            
            // Создаем ResponseRecorder
            rr := httptest.NewRecorder()
            
            // Вызываем handler
            getUserHandler(rr, req)
            
            // Проверяем статус
            if rr.Code != tt.expectedStatus {
                t.Errorf("Ожидался статус %d, получен %d", tt.expectedStatus, rr.Code)
            }
            
            // Проверяем тело ответа для успешных запросов
            if tt.expectedUser != nil {
                var user User
                if err := json.NewDecoder(rr.Body).Decode(&user); err != nil {
                    t.Fatalf("Ошибка парсинга JSON: %v", err)
                }
                
                if user != *tt.expectedUser {
                    t.Errorf("Ожидался пользователь %+v, получен %+v", *tt.expectedUser, user)
                }
            }
        })
    }
}

func TestCreateUserHandler(t *testing.T) {
    tests := []struct {
        name           string
        requestBody    string
        expectedStatus int
        expectedName   string
    }{
        {
            name:           "Валидный пользователь",
            requestBody:    `{"name": "Петр"}`,
            expectedStatus: http.StatusCreated,
            expectedName:   "Петр",
        },
        {
            name:           "Пустое имя",
            requestBody:    `{"name": ""}`,
            expectedStatus: http.StatusBadRequest,
            expectedName:   "",
        },
        {
            name:           "Неверный JSON",
            requestBody:    `{"name":}`,
            expectedStatus: http.StatusBadRequest,
            expectedName:   "",
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            // Создаем запрос с телом
            req := httptest.NewRequest(http.MethodPost, "/users", bytes.NewBufferString(tt.requestBody))
            req.Header.Set("Content-Type", "application/json")
            
            rr := httptest.NewRecorder()
            
            createUserHandler(rr, req)
            
            if rr.Code != tt.expectedStatus {
                t.Errorf("Ожидался статус %d, получен %d", tt.expectedStatus, rr.Code)
            }
            
            // Проверяем созданного пользователя
            if tt.expectedStatus == http.StatusCreated {
                var user User
                if err := json.NewDecoder(rr.Body).Decode(&user); err != nil {
                    t.Fatalf("Ошибка парсинга JSON: %v", err)
                }
                
                if user.Name != tt.expectedName {
                    t.Errorf("Ожидалось имя '%s', получено '%s'", tt.expectedName, user.Name)
                }
                
                if user.ID == 0 {
                    t.Error("ID пользователя не должен быть 0")
                }
            }
        })
    }
}

// Интеграционный тест с сервером
func TestUserAPIIntegration(t *testing.T) {
    // Создаем тестовый сервер
    mux := http.NewServeMux()
    mux.HandleFunc("/users/", getUserHandler)
    mux.HandleFunc("/users", createUserHandler)
    
    server := httptest.NewServer(mux)
    defer server.Close()
    
    // Создаем пользователя
    createReq := `{"name": "Тестовый пользователь"}`
    resp, err := http.Post(server.URL+"/users", "application/json", bytes.NewBufferString(createReq))
    if err != nil {
        t.Fatalf("Ошибка создания пользователя: %v", err)
    }
    defer resp.Body.Close()
    
    if resp.StatusCode != http.StatusCreated {
        t.Fatalf("Ожидался статус 201, получен %d", resp.StatusCode)
    }
    
    // Декодируем созданного пользователя
    var createdUser User
    if err := json.NewDecoder(resp.Body).Decode(&createdUser); err != nil {
        t.Fatalf("Ошибка парсинга созданного пользователя: %v", err)
    }
    
    // Получаем пользователя по ID
    getUserURL := fmt.Sprintf("%s/users/%d", server.URL, createdUser.ID)
    resp2, err := http.Get(getUserURL)
    if err != nil {
        t.Fatalf("Ошибка получения пользователя: %v", err)
    }
    defer resp2.Body.Close()
    
    if resp2.StatusCode != http.StatusOK {
        t.Fatalf("Ожидался статус 200, получен %d", resp2.StatusCode)
    }
    
    var fetchedUser User
    if err := json.NewDecoder(resp2.Body).Decode(&fetchedUser); err != nil {
        t.Fatalf("Ошибка парсинга полученного пользователя: %v", err)
    }
    
    // Проверяем, что пользователи одинаковые
    if fetchedUser != createdUser {
        t.Errorf("Созданный и полученный пользователи не совпадают: %+v != %+v", createdUser, fetchedUser)
    }
}
```

Запуск тестов:
```bash
go test -v
```

---