# Список базовых вопросов

1. Concurency
- Что такое горутина (отвечать стоит в ключе что такое сопрограмма, корутины, горутины, файброри, гринтряды). 
- Какое преймущество использования?
- Рассказать какой контекст у горутины, а какой у потока операционной системы.
- В чем разница context switching'а у горутины и потока.
- Что такое примитивы синхронизации?
- Что такое мьютекс? Как он устроен? Как он работает?
- Что происходит с горутиной, когда она вызывает метод Lock
- Рассказать про остальные примитивы из стандартной библиотеки
- Проблемы concurency программирования. Deadlock, Livelock, data race, race condition
2. Планировщик Golang
- Модели многозадачности (кооперативная и вытесняющая)
- Какую модель использует планировщик?
- Что такое GMP модель? Как она устроена? Как между собой взаимодействует?
- Что такое глобальная и локальная очередь?
- Как и где находятся горутины и как они перемещаются между этими очередями?
- Что такое work steam и почему именно он там используется, а не work sharing?
- В какой момент горутины переключаются?
- Что такое Netpoller и sysmoon и какую роль они играют внутри планировщика
- Что происходит с горутиной когда она вызывает какой нибудь syscall
3. Каналы
- Как внутри устроены каналы?
- Как устроен кольцевой буфер в каналах?
- Какие есть очереди внутри? Какую роль они там играют
- В чем разница буферезированного от небуферезированного канала?
- Какие существуют паттерны использования каналов? Что такое Pipe, Fan In Fan Out. Как бы вы это реализовали? Явно тоже нужно уметь делать
- Невалидные операции с каналами
4. Память
- С какого размера начинается стек горутин? Как он динамически растет?
- Что такое continues стек? Что такое segmented стек? Где находится стек горутин?
- Аллокатор golang. Как он выделяет память? 
- Garbage Collector. Как устроен? По какой модели он работает? Какие у него основные фазы? На каких фазах осуществляется полная остановка программы? Как можно самому программисту нагло им управлять?
5. Слайсы и мапы
- В чем отличие слайса и массива
- Как устроен слайс? Какова его стратегия динамического расширения?
- Асимптотика работы со слайсами.
- Что будет если читать/писать в nil слайс?
- Как устроена мапа?
- Что такое hash таблица?
- Что такое hash коллизия?
- Что такое load factor?
- Способы разрешения подобных коллизий?
- Как происходит реиндексация?
- Что такое невалидные операции? Что будет если читать/писать в nil map? 
6. Строки
- Как внутри устроены строки?
- Почему строки в го иммутабельны?
- И если они иммутабельны то могу ли я изменить какой либо символ?
- Как происходит конкатенация этих иммутабельных строк?
- Как посчитать кол-во символов в строке?
- Что такое rune?
- В чем разница прохода по строке с помощью range и через индекс?
7. ООП
- Как реализовано ООП в го?
- Какие концепции реализуются в го исходя из этой концепции?
- Что такое утиная типизация?
- Что такое интерфейс? Как он внутри реализован?
- Как привезти тип одного интерфейса к другому?
- Как проверить тип интерфейса?
- Что такое type assert?
- Что такое пустой интерфейс?
- Разобраться с неочевидными cases с nil интерфейсами
8. Дополнительные вопросы
- Вопросы про указатели. Особенно про указатели на указатели.
- Вопросы связанные с контекстом. Что это такое? Что такое Graceful shutdown? Как реализованы контексты? Как бы вы реализовали contextWithCancel и contextWithTimeout?
- Рефлексия
- Дженерики

======
# Краткие ответы

## Concurency

### **Что такое горутина?**

Горутина — это легковесная единица выполнения, аналогичная сопрограмме (coroutine). Это не поток ОС, а сущность, управляемая рантаймом Go. Горутины ближе к **файберам** (fibers) или **гринтредам** (green threads) — то есть, они запускаются и планируются на уровне рантайма, а не ОС.

Корутины в общем смысле — это функции, которые можно приостанавливать и возобновлять. В Go они не приостанавливаются вручную, но под капотом используют кооперативную многозадачность, что роднит их с корутинами.

---

### **Преимущества горутин:**

* **Лёгкие:** стартуются с 2 KB стека (в отличие от \~1MB у потоков ОС).
* **Масштабируемые:** можно запускать десятки тысяч без проблем.
* **Быстрый старт и переключение:** дешевле, чем системные потоки.
* **Встроенная поддержка:** планировщик и синхронизация встроены в язык.

---

### **Контекст горутины и потока ОС:**

* **Контекст потока ОС:** регистры, стек, дескрипторы и ресурсы ядра. Переключение дорогостоящее.
* **Контекст горутины:** только стек, программный счётчик, несколько регистров. Переключение осуществляется в userspace (на уровне рантайма), дешево.

---

### **Разница в context switching:**

* Поток ОС: требует перехода в kernel mode → дорого.
* Горутина: переключается рантаймом Go в user mode → быстро и легко.

---

### **Что такое примитивы синхронизации?**

Это средства управления доступом к разделяемым ресурсам:

* `sync.Mutex`, `sync.RWMutex`
* `sync.WaitGroup`
* `sync.Once`
* `sync.Cond`
* `sync.Map`
* `atomic` из `sync/atomic`

---

### **Мьютекс: как устроен и работает?**

* `sync.Mutex` реализован через CAS (compare-and-swap) и очередь ожидания.
* Состояния: **unlocked = 0**, **locked = 1**
* При `Lock()`:

  * Если свободен — захватывает.
  * Если занят — помещает горутину в очередь ожидания и блокирует.
* При `Unlock()`:

  * Снимает блокировку, разбуживает следующую.

---

### **Что происходит с горутиной, когда она вызывает `Lock`?**

* Если мьютекс занят → горутина блокируется и снимается с выполнения.
* Помещается в очередь мьютекса.
* Возобновляется планировщиком, когда ресурс освобожден.

---

### **Остальные примитивы:**

* `RWMutex`: разделяет доступ на чтение/запись.
* `WaitGroup`: ждёт завершения группы горутин.
* `Once`: гарантирует однократный вызов.
* `Cond`: сигнализация между горутинами (обычно вместе с мьютексами).
* `sync.Map`: потокобезопасная map.
* `atomic`: предоставляет операции без блокировок (например, `AddInt32`, `CompareAndSwap`).

---

### **Проблемы конкурентного программирования:**

* **Deadlock** — взаимная блокировка (оба ждут друг друга).
* **Livelock** — не блокируются, но крутятся в ожидании.
* **Race condition** — результат зависит от порядка выполнения.
* **Data race** — два потока одновременно читают/пишут без синхронизации (UB).

  > Проверяется `go run -race`.

---

## Планировщик

### **Модели многозадачности: кооперативная vs вытесняющая**

* **Кооперативная (cooperative):**

  * Поток добровольно уступает управление.
  * Быстрее, но если поток завис — всё висит.
* **Вытесняющая (preemptive):**

  * Планировщик принудительно переключает контекст.
  * Надёжнее, но дороже (нужно вмешательство ядра или таймеры).

---

### **Какую модель использует планировщик Go?**

Go использует **комбинацию**:

* Ранее (до Go 1.14): **кооперативная**, через явные точки переключения (например, `channel`, `time.Sleep`, `runtime.Gosched()`).
* Сейчас (с Go 1.14): **вытесняющая** появилась через таймеры и preemption-сигналы → горутина может быть прервана даже во время цикла.

---

### **Что такое GMP-модель?**

Это модель исполнения горутин в Go:

* **G (goroutine)** — пользовательская задача.
* **M (machine)** — системный поток ОС.
* **P (processor)** — логический процессор (владеет очередью G и исполняет G на M).

**Суть:**

* `M` не может выполнять `G` без `P`.
* `P` даёт `M` доступ к runqueue с `G`.

---

### **Как взаимодействуют G, M, P:**

1. `P` хранит очередь `G`.
2. `M` запрашивает `P`, чтобы исполнять `G`.
3. Один `P` → один активный `M`.
4. Число `P` задается через `GOMAXPROCS` (по умолчанию — кол-во логических ядер).

---

### **Что такое глобальная и локальная очередь?**

* **Локальная очередь**: очередь G внутри `P`, LIFO.
* **Глобальная очередь**: общий пул всех горутин (FIFO).
* Планировщик сначала берёт G из локальной очереди, потом — из глобальной.

---

### **Как находятся и перемещаются горутины между очередями?**

* Новые горутины добавляются в **локальную очередь** текущего `P`.
* Если локальная пуста — `P` может брать G из:

  * глобальной очереди;
  * чужой локальной очереди через **work stealing**.

---

### **Что такое work stealing и почему используется?**

**Work stealing** — техника, при которой `P`, оставшийся без работы, ворует `G` из другого `P`.

**Почему не work sharing?**

* Work sharing: активный `P` сам делится — это нагрузка на активных исполнителей.
* Work stealing: пассивный `P` ищет работу — масштабируется лучше, снижает contention.

---

### **В какой момент горутины переключаются?**

* Явные точки: `channel`, `select`, `sync`, `sleep`, `yield`, `IO`, `syscall`.
* С Go 1.14: таймеры и счётчики — переключение происходит и при долгом исполнении без явного вызова.

---

### **Что такое Netpoller и Sysmon?**

* **Netpoller:**

  * Слушает сетевые события (`epoll`, `kqueue`, `IOCP`).
  * Пробуждает горутину, если сокет стал доступен.
* **Sysmon (System Monitor):**

  * Горутина планировщика.
  * Отвечает за preemption, уборку памяти, таймеры, остановку "висящих" `M`.

---

### **Что происходит с горутиной, когда она вызывает syscall?**

* Поток `M` блокируется, потому что syscall может быть долгим.
* Его `P` отбирается и передаётся другому `M`, чтобы не простаивал.
* Когда syscall завершается — `M` пытается вернуть `P` или кладёт `G` в глобальную очередь.

Отлично, продолжаем — **блок 3: Каналы в Go**. Ниже развернутые, собеседовательные ответы с техническими деталями и возможностью быстро вспоминать.

---

## Каналы

### **Как внутри устроены каналы?**

Канал (`chan`) — это структура, которая реализует потокобезопасную передачу данных между горутинами.

Внутри он состоит из:

* кольцевого буфера (если канал буферизованный),
* очереди **отправителей (sendq)**,
* очереди **получателей (recvq)**,
* мьютекса и блокировок.

---

### **Как устроен кольцевой буфер в каналах?**

* Буфер — массив фиксированного размера.
* Имеет два указателя:

  * **head**: откуда читать,
  * **tail**: куда писать.
* Когда head == tail — канал пуст или полон (в зависимости от счётчика элементов).
* Вставка/извлечение происходит по модулю длины (по кольцу).

---

### **Какие есть очереди внутри? Какую роль они играют?**

* **sendq (send queue)** — горутины, ожидающие, пока можно будет записать (если буфер полон или канал небуферизованный и нет читателя).
* **recvq (receive queue)** — горутины, ожидающие данные (если буфер пуст или канал небуферизованный и нет отправителя).

При возможности передачи — горутины разблокируются напрямую, без использования буфера.

---

### **Разница буферизованного и небуферизованного канала:**

| Тип              | Передача данных                              | Блокировка                                  |
| ---------------- | -------------------------------------------- | ------------------------------------------- |
| Небуферизованный | Только при наличии получателя                | `send` блокируется, пока не будет `recv`    |
| Буферизованный   | Можно писать без получателя, если есть место | `send` блокируется только при полном буфере |

**Пример:**
`make(chan int)` — небуферизованный
`make(chan int, 5)` — буферизованный на 5 значений

---

### **Паттерны использования каналов:**

#### **1. Pipe (канал как поток):**

* Используется для передачи данных из одного места в другое.

```go
func generate() <-chan int {
    ch := make(chan int)
    go func() {
        for i := 0; ; i++ {
            ch <- i
        }
    }()
    return ch
}
```

#### **2. Fan-in (объединение каналов):**

* Собирает данные от нескольких источников в один канал.

```go
func fanIn(a, b <-chan int) <-chan int {
    out := make(chan int)
    go func() {
        for {
            select {
            case v := <-a:
                out <- v
            case v := <-b:
                out <- v
            }
        }
    }()
    return out
}
```

#### **3. Fan-out (рассылка в несколько обработчиков):**

* Распараллеливает обработку одного входа на несколько воркеров.

```go
func worker(id int, ch <-chan int) {
    for v := range ch {
        fmt.Println("Worker", id, "got", v)
    }
}
```

---

### **Невалидные операции с каналами:**

| Операция                            | Поведение                            |
| ----------------------------------- | ------------------------------------ |
| Отправка в закрытый канал           | `panic`                              |
| Чтение из закрытого канала          | Возвращает zero-value и `ok = false` |
| Закрытие уже закрытого канала       | `panic`                              |
| Закрытие канала для чтения (`<-ch`) | Ошибка компиляции                    |
| Закрытие nil-канала                 | `panic`                              |
| Отправка/чтение в nil-канал         | Блокировка навсегда                  |

---

## Память

### **С какого размера начинается стек горутин? Как он растёт?**

* **Начальный размер стека горутины:** \~2 KB.
* **Динамический рост:** при необходимости стек **удваивается** (копируется в новый, больший блок).
* Это отличается от системных потоков, где стек статичен и велик (1MB+).

---

### **Что такое contiguous stack и segmented stack?**

* **Contiguous stack (Go ≥ 1.4):** стек горутины — единый блок памяти, который копируется при увеличении.
* **Segmented stack (Go < 1.4):** стек состоял из цепочки фрагментов. Медленнее, сложнее — отказались.

> Сейчас Go использует **contiguous stacks** с удвоением, что позволяет простое обращение по стеку (например, `defer`-цепочка).

---

### **Где находятся стеки горутин?**

* Выделяются из **heap** памяти (кучи), а не как в ОС — из виртуальной памяти.
* Рантайм отслеживает использование и расширяет по мере надобности.

---

### **Как устроен аллокатор Go?**

Go использует **раздельный аллокатор**:

* **Tiny allocator:** для объектов < 16 байт (например, `struct{}` или `bool`).
* **Span allocator:** память разбита на **spans** (8 KB), объединяющиеся в **arenas**.
* **MCache / MSpan / MCentral:** локальные и глобальные пулы памяти для ускорения.

Память выделяется через `mallocgc`, но благодаря аренам и кэшам аллокация очень быстрая.

---

### **Garbage Collector (GC) в Go:**

Современный GC — **трехцветный, инкрементальный, конкурентный** (с 1.5+).

**Фазы:**

1. **STW Mark Start (стоп мира)** — остановка мира, инициализация GC.
2. **Concurrent Mark** — потоки отмечают доступные объекты.
3. **STW Mark Terminate** — короткая остановка мира.
4. **Concurrent Sweep** — освобождение недоступной памяти.

---

### **На каких фазах происходит полная остановка мира?**

* **Mark Start**
* **Mark Terminate**

> Каждая длится миллисекунды. GC работает параллельно с программой (до 25% CPU может потребляться GC).

---

### **Можно ли управлять GC вручную?**

В Go **нельзя полностью отключить GC**, но можно влиять:

* `runtime.GC()` — принудительно запустить сборку мусора.
* `debug.SetGCPercent(x)` — управлять агрессивностью (100 — стандарт, 0 — отключение GC до переполнения).
* `runtime.ReadMemStats` — получить статистику.
* Использование `sync.Pool` — влияет на давление на GC.

---

## Слайсы и мапы

Отлично, теперь — **блок 5: Слайсы и мапы**. Это часто спрашивают как на знание устройства, так и на ловушки.

---

## **5. Слайсы и мапы в Go**

### **В чём отличие слайса и массива?**

* **Массив (`[N]T`)** — фиксированная длина, копируется по значению.
* **Слайс (`[]T`)** — "умная обёртка" над массивом: динамический размер, ссылочный тип.

> Слайс содержит:

1. Указатель на первый элемент массива.
2. Длину (len).
3. Вместимость (cap).

---

### **Как устроен слайс?**

```go
type slice struct {
    ptr *T     // указатель на данные
    len int
    cap int
}
```

* Слайс указывает на массив, но сам не хранит элементы.
* Несколько слайсов могут указывать на один и тот же массив → важно помнить об изменениях.

---

### **Стратегия динамического расширения слайса:**

* При добавлении через `append`, если `len < cap` → просто увеличивается длина.
* Если места не хватает → создаётся новый массив:

  * Для маленьких слайсов: cap \*= 2
  * Для больших: рост медленнее (до \~25%)
* Старый массив не удаляется — он попадёт под GC.

---

### **Асимптотика работы со слайсами:**

| Операция                    | Сложность                 |
| --------------------------- | ------------------------- |
| Чтение по индексу           | O(1)                      |
| Добавление в конец          | O(1)\* — амортизированное |
| Вставка в середину          | O(n)                      |
| Удаление из начала/середины | O(n)                      |

---

### **Что будет, если читать/писать в `nil` слайс?**

* `nil` слайс: `var s []int`

  * `len(s) == 0`, `cap(s) == 0`, `s == nil`
* **Чтение** по индексу — `panic: index out of range`
* **Запись** — тоже panic
* `append(s, ...)` работает — создаётся новый слайс

---

### **Как устроена мапа?**

Map (`map[K]V`) реализована как **хеш-таблица с open addressing и overflow buckets**.

Основные компоненты:

* **Buckets**: массив структур, хранящих ключи и значения.
* **Tophash**: оптимизация по верхним 8 битам хеша.
* **Overflow**: дополнительные бакеты при коллизиях.

---

### **Что такое хеш-таблица?**

* Структура данных, использующая хеш-функцию для быстрого доступа по ключу.
* `map[key] = value` — амортизированное O(1) время.

---

### **Что такое hash-коллизия?**

* Когда два ключа дают одинаковый хеш → идут в один bucket.
* В Go реализовано через **open addressing** с цепочкой overflow-бакетов.

---

### **Что такое load factor?**

* Отношение количества элементов к количеству бакетов.
* При достижении порога (обычно \~6.5) → происходит **реалокация и реиндексация**.

---

### **Как происходит реиндексация?**

* Go **лениво** переносит данные в новый бакет:

  * при доступе к старому ключу — он мигрируется.
  * минимизирует время "стоп мира".

---

### **Невалидные операции с map:**

| Операция                          | Поведение                       |
| --------------------------------- | ------------------------------- |
| Чтение из `nil` map               | `zero-value`, не panic          |
| Запись в `nil` map                | `panic`                         |
| Удаление из `nil` map             | `panic`                         |
| Обход `nil` map через `for range` | Пропускается, не вызывает panic |

---

## Строки

### **Как внутри устроены строки?**

Строка (`string`) — **иммутабельная обёртка** над срезом байт (`[]byte`), то есть:

```go
type string struct {
    ptr *byte
    len int
}
```

* Хранит байты, закодированные в **UTF-8**.
* Не обязательно каждый символ занимает 1 байт — может 2, 3 или 4.

---

### **Почему строки иммутабельны?**

* Чтобы быть **безопасными при передаче между горутинами**.
* Чтобы иметь **copy-on-write** семантику (возможна оптимизация памяти).
* Это часть дизайна языка — нельзя менять строку по индексу.

---

### **Могу ли я изменить символ строки?**

**Нет.**

* Строка иммутабельна, даже если взять `[]byte(s)` — получится копия.

Пример:

```go
s := "hello"
s[0] = 'H' // ❌ компилятор не позволит
```

Чтобы "изменить" строку:

```go
b := []byte(s)
b[0] = 'H'
s2 := string(b)
```

---

### **Как происходит конкатенация строк?**

* Каждый `+` → новая строка, аллокация новой памяти.
* Можно использовать `strings.Builder` для эффективной сборки:

```go
var b strings.Builder
b.WriteString("hello")
b.WriteString("world")
s := b.String()
```

---

### **Как посчитать количество символов в строке?**

* **`len(s)`** — количество **байт**, не символов.
* Чтобы посчитать **символы (runes)**:

```go
count := utf8.RuneCountInString(s)
```

---

### **Что такое `rune`?**

* `rune` — псевдоним для `int32`
* Представляет **один Unicode-символ**
* В UTF-8 может занимать 1–4 байта

---

### **Проход по строке: `range` vs индексы**

#### Пример:

```go
s := "привет"
for i := 0; i < len(s); i++ {
    fmt.Printf("%c ", s[i]) // печатает байты
}
for i, r := range s {
    fmt.Printf("%c ", r) // печатает руны (Unicode)
}
```

| Метод   | Что возвращает           | Когда использовать                             |
| ------- | ------------------------ | ---------------------------------------------- |
| `range` | индекс в байтах + `rune` | при работе с Unicode                           |
| индекс  | байты (`s[i]`)           | при работе с ASCII / низкоуровневой обработкой |

---

## ООП и интерфейсы

Отлично, теперь — **блок 7: ООП и интерфейсы в Go**. Этот блок часто проверяют на глубину понимания динамической типизации, внутреннего устройства интерфейсов и нюансов с `nil`.

---

## **7. ООП в Go и интерфейсы**

Go **не использует классы**, но поддерживает ООП через:

* **структуры (`struct`)**
* **методы** (приёмники)
* **интерфейсы** (поведение через абстракцию)

Go — это **композиционное ООП**, а не наследование.

---

### **Какие концепции ООП поддерживает Go?**

* **Инкапсуляция:** через экспортируемые/неэкспортируемые поля (`A` vs `a`)
* **Полиморфизм:** через интерфейсы
* **Композиция:** `struct` внутри `struct` (встраивание)
* **Наследование:** нет, вместо него — **встраивание и интерфейсы**

---

### **Что такое "утиная типизация"?**

> “If it walks like a duck and quacks like a duck, it’s a duck.”

* Тип удовлетворяет интерфейсу **не по явному объявлению**, а **по наличию нужных методов**.
* Интерфейсы **не требуют `implements`**.

Пример:

```go
type Walker interface {
    Walk()
}

type Person struct{}

func (p Person) Walk() {}

var w Walker = Person{} // OK: Person реализует Walker
```

---

### **Что такое интерфейс? Как он реализован внутри?**

Интерфейс в Go — это структура:

```go
type iface struct {
    tab  *itab    // таблица методов + тип
    data unsafe.Pointer // указатель на данные
}
```

* `data` — указатель на значение, реализующее интерфейс.
* `itab` — содержит тип и таблицу методов.
* Вызов метода — через **виртуальную таблицу (vtable)**.

---

### **Как привести один интерфейс к другому?**

* Через **type assertion** или **type conversion**:

```go
var r io.Reader
var c io.Closer
c = r.(io.Closer)     // assert
c = io.Closer(r)      // convert — OK только если r уже Closer
```

* Работает, если `r` реализует методы `Closer`.

---

### **Как проверить тип интерфейса?**

* Использовать **type assertion** с `ok`:

```go
v, ok := i.(int)
```

* Или **type switch**:

```go
switch v := i.(type) {
case string:
    fmt.Println("строка", v)
case int:
    fmt.Println("число", v)
}
```

---

### **Что такое type assertion?**

Это попытка извлечь значение конкретного типа из интерфейса:

```go
i := interface{}(42)
v := i.(int)       // OK
v2 := i.(string)   // panic!
v3, ok := i.(string) // ok == false
```

---

### **Что такое пустой интерфейс (`interface{}`)?**

* Интерфейс, не содержащий ни одного метода.
* Может **принимать значение любого типа**.
* Используется в:

  * `fmt.Println`
  * `json.Unmarshal`
  * `map[string]interface{}`

---

### **Нюансы с `nil` интерфейсами:**

Очень частый вопрос!

```go
var err error = nil // OK
```

Но:

```go
var ptr *MyType = nil
var i interface{} = ptr
fmt.Println(i == nil) // ❌ false!
```

> Потому что `i` не `nil`: он содержит `(тип: *MyType, значение: nil)`.
> Для `interface == nil` оба поля (`type` и `data`) должны быть `nil`.

---

## Указатели, контексты, рефлексия, дженерики

### 🔹 **Указатели**

#### **Что такое указатель?**

* Указатель (`*T`) — это переменная, хранящая **адрес** значения типа `T`.
* `&v` — взять адрес.
* `*p` — разыменовать.

#### **Указатели на указатели:**

```go
var x int = 10
var p *int = &x
var pp **int = &p
fmt.Println(**pp) // 10
```

* Используются редко, в основном при изменении указателя в функции.
* Лучше избегать без явной необходимости — часто признак архитектурной ошибки.

---

### 🔹 **Контекст (`context.Context`)**

#### **Что это такое?**

* Интерфейс, передающий **тайм-ауты**, **отмену**, **значения** по дереву вызовов.
* Помогает управлять жизненным циклом операций и горутин.

#### **Типы:**

* `context.Background()` — корень дерева.
* `context.TODO()` — временный placeholder.
* `WithCancel`, `WithTimeout`, `WithDeadline`, `WithValue`

---

#### **Что такое Graceful shutdown?**

* **Мягкое завершение** сервиса:

  * Завершить обработку текущих запросов.
  * Освободить ресурсы.
  * Закрыть соединения.

Обычно реализуется через:

```go
ctx, cancel := context.WithCancel(context.Background())

go func() {
    <-signalChan
    cancel()
}()
```

---

#### **Как реализованы `WithCancel`, `WithTimeout`:**

* Оборачивают родительский `Context` в структуру с `done` каналом.
* `WithCancel` вручную вызывает `cancel()` — закрывает `done`.
* `WithTimeout` запускает таймер → автоматически вызывает `cancel`.

Внутри — дерево контекстов, отмена передаётся всем "дочерним".

---

### 🔹 **Рефлексия (`reflect` package)**

#### **Что такое рефлексия?**

* Механизм получения информации о типах **во время выполнения**.
* Позволяет:

  * Проверять типы.
  * Создавать значения.
  * Вызывать методы.

Пример:

```go
v := reflect.ValueOf(42)
fmt.Println(v.Kind()) // int
```

#### **Риски:**

* Медленнее, чем статический код.
* Не проверяется компилятором.
* Лучше использовать аккуратно (например, для сериализации или DI).

---

### 🔹 **Дженерики (Go 1.18+)**

#### **Что такое дженерики?**

* Возможность писать **обобщённый код**, параметризованный типами.

Пример:

```go
func Min[T constraints.Ordered](a, b T) T {
    if a < b {
        return a
    }
    return b
}
```

#### **Зачем они нужны?**

* Избавляют от дублирования кода.
* Устраняют необходимость в `interface{}` и `reflect` в простых случаях.
* Повышают читаемость и типобезопасность.

---

#### **Сравнение с интерфейсами:**

| Интерфейсы                   | Дженерики                         |
| ---------------------------- | --------------------------------- |
| Поведение                    | Тип                               |
| Динамическое                 | Статическое                       |
| Работают во время выполнения | Подставляются во время компиляции |
| Могут быть `nil`             | Нельзя "указать" `nil` обобщённо  |

