**–ö–ª—é—á–µ–≤—ã–µ –∞–∫—Ü–µ–Ω—Ç—ã –¥–ª—è –ø–æ–¥–≥–æ—Ç–æ–≤–∫–∏:**

## üéØ –û–±—è–∑–∞—Ç–µ–ª—å–Ω–æ –∑–Ω–∞—Ç—å:

**OWASP Top 10 —Å –ø—Ä–∏–º–µ—Ä–∞–º–∏ –Ω–∞ Go:**

- SQL Injection + –ø–∞—Ä–∞–º–µ—Ç—Ä–∏–∑–æ–≤–∞–Ω–Ω—ã–µ –∑–∞–ø—Ä–æ—Å—ã
- XSS + HTML escaping
- CSRF + SameSite cookies
- Broken Authentication + bcrypt hashing

**DAST —Å–ø–µ—Ü–∏—Ñ–∏–∫–∞:**

- –ê–∫—Ç–∏–≤–Ω–æ–µ vs –ø–∞—Å—Å–∏–≤–Ω–æ–µ —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ
- Web crawling –∏ fuzzing
- Payload management
- False positive –∞–Ω–∞–ª–∏–∑

## üöÄ –ß—Ç–æ –ø–æ–∫–∞–∂–µ—Ç —ç–∫—Å–ø–µ—Ä—Ç–∏–∑—É:

**–ü—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏–µ –Ω–∞–≤—ã–∫–∏:**

- –£–º–µ–Ω–∏–µ –Ω–∞–π—Ç–∏ —É—è–∑–≤–∏–º–æ—Å—Ç—å –≤ Go –∫–æ–¥–µ –∑–∞ 30 —Å–µ–∫—É–Ω–¥
- –ó–Ω–∞–Ω–∏–µ secure coding practices
- –ü–æ–Ω–∏–º–∞–Ω–∏–µ –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—ã –≤–µ–±-—Å–∫–∞–Ω–µ—Ä–æ–≤

**–°–∏—Å—Ç–µ–º–Ω–æ–µ –º—ã—à–ª–µ–Ω–∏–µ:**

- –ö–∞–∫ –∏–Ω—Ç–µ–≥—Ä–∏—Ä–æ–≤–∞—Ç—å DAST –≤ CI/CD
- –ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å —Å–∞–º–æ–≥–æ —Å–∫–∞–Ω–µ—Ä–∞
- –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –∏ alerting

## üí° –õ–∞–π—Ñ—Ö–∞–∫ –¥–ª—è —Å–æ–±–µ—Å–µ–¥–æ–≤–∞–Ω–∏—è:

–ü–æ–¥–≥–æ—Ç–æ–≤—å—Ç–µ **–∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–π –ø—Ä–∏–º–µ—Ä** —É—è–∑–≤–∏–º–æ—Å—Ç–∏, –∫–æ—Ç–æ—Ä—É—é –≤—ã –Ω–∞—Ö–æ–¥–∏–ª–∏ –∏–ª–∏ –∏—Å–ø—Ä–∞–≤–ª—è–ª–∏. –≠—Ç–æ –ø–æ–∫–∞–∂–µ—Ç –ø—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏–π –æ–ø—ã—Ç –∏ –≤—ã–¥–µ–ª–∏—Ç –≤–∞—Å —Å—Ä–µ–¥–∏ –¥—Ä—É–≥–∏—Ö –∫–∞–Ω–¥–∏–¥–∞—Ç–æ–≤.

**–ü—Ä–∏–º–µ—Ä —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –æ—Ç–≤–µ—Ç–∞:**

1. "–ö–∞–∫—É—é —É—è–∑–≤–∏–º–æ—Å—Ç—å –Ω–∞—à–ª–∏"
2. "–ö–∞–∫ –µ—ë —ç–∫—Å–ø–ª—É–∞—Ç–∏—Ä–æ–≤–∞–ª–∏"
3. "–ö–∞–∫ –∏—Å–ø—Ä–∞–≤–∏–ª–∏ –≤ Go –∫–æ–¥–µ"
4. "–ö–∞–∫ –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—Ç–∏–ª–∏ –≤ –±—É–¥—É—â–µ–º"

# –ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å –¥–ª—è DAST Go —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–∞

## üéØ OWASP Top 10 - –æ—Å–Ω–æ–≤–∞ DAST —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è

### 1. **Injection (–ò–Ω—ä–µ–∫—Ü–∏–∏)**

**SQL Injection:**

```sql
-- –£—è–∑–≤–∏–º—ã–π –∑–∞–ø—Ä–æ—Å
SELECT * FROM users WHERE id = '$user_input'

-- –≠–∫—Å–ø–ª–æ–π—Ç
' OR 1=1--

-- –ë–µ–∑–æ–ø–∞—Å–Ω—ã–π –ø–æ–¥—Ö–æ–¥ –≤ Go
db.Query("SELECT * FROM users WHERE id = $1", userID)
```

**Command Injection:**

```go
// –£—è–∑–≤–∏–º–æ
cmd := exec.Command("ping", userInput)

// –ë–µ–∑–æ–ø–∞—Å–Ω–æ
if !regexp.MustMatch(`^[a-zA-Z0-9.-]+$`, userInput) {
    return errors.New("invalid input")
}
```

**–ö–∞–∫ DAST —ç—Ç–æ –Ω–∞—Ö–æ–¥–∏—Ç:**

- –û—Ç–ø—Ä–∞–≤–∫–∞ —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã—Ö payload'–æ–≤
- –ê–Ω–∞–ª–∏–∑ –æ—Ç–≤–µ—Ç–æ–≤ –Ω–∞ –Ω–∞–ª–∏—á–∏–µ SQL –æ—à–∏–±–æ–∫
- Timing-based –∞—Ç–∞–∫–∏

### 2. **Broken Authentication (–ù–∞—Ä—É—à–µ–Ω–Ω–∞—è –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è)**

```go
// –ü—Ä–æ–±–ª–µ–º—ã:
- –°–ª–∞–±—ã–µ –ø–∞—Ä–æ–ª–∏
- Session hijacking
- Brute force –∞—Ç–∞–∫–∏
- –ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω–æ–µ —Ö—Ä–∞–Ω–µ–Ω–∏–µ —Å–µ—Å—Å–∏–π

// –ë–µ–∑–æ–ø–∞—Å–Ω–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è JWT –≤ Go
func generateJWT(userID string) (string, error) {
    token := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{
        "user_id": userID,
        "exp":     time.Now().Add(time.Hour * 24).Unix(),
    })
    return token.SignedString([]byte(os.Getenv("JWT_SECRET")))
}
```

### 3. **Sensitive Data Exposure (–£—Ç–µ—á–∫–∞ —á—É–≤—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö)**

```go
// –ü—Ä–æ–±–ª–µ–º—ã:
- –ü–µ—Ä–µ–¥–∞—á–∞ –ø–∞—Ä–æ–ª–µ–π –≤ –æ—Ç–∫—Ä—ã—Ç–æ–º –≤–∏–¥–µ
- –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ sensitive –¥–∞–Ω–Ω—ã—Ö
- –û—Ç—Å—É—Ç—Å—Ç–≤–∏–µ HTTPS

// –ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ —Ö–µ—à–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–∞—Ä–æ–ª–µ–π
import "golang.org/x/crypto/bcrypt"

func hashPassword(password string) (string, error) {
    bytes, err := bcrypt.GenerateFromPassword([]byte(password), 14)
    return string(bytes), err
}
```

### 4. **XML External Entities (XXE)**

```go
// –£—è–∑–≤–∏–º—ã–π XML –ø–∞—Ä—Å–∏–Ω–≥
decoder := xml.NewDecoder(req.Body)

// –ë–µ–∑–æ–ø–∞—Å–Ω—ã–π –ø–æ–¥—Ö–æ–¥
decoder := xml.NewDecoder(req.Body)
decoder.Strict = false
decoder.Entity = make(map[string]string) // –û—Ç–∫–ª—é—á–µ–Ω–∏–µ –≤–Ω–µ—à–Ω–∏—Ö —Å—É—â–Ω–æ—Å—Ç–µ–π
```

### 5. **Broken Access Control**

```go
// –ü—Ä–æ–±–ª–µ–º–∞: –æ—Ç—Å—É—Ç—Å—Ç–≤–∏–µ –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø—Ä–∞–≤ –¥–æ—Å—Ç—É–ø–∞
func getUser(w http.ResponseWriter, r *http.Request) {
    userID := r.URL.Query().Get("id")
    // –õ—é–±–æ–π –º–æ–∂–µ—Ç –ø–æ–ª—É—á–∏—Ç—å –¥–∞–Ω–Ω—ã–µ –ª—é–±–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    user := getUserFromDB(userID)
    json.NewEncoder(w).Encode(user)
}

// –ü—Ä–∞–≤–∏–ª—å–Ω–æ: –ø—Ä–æ–≤–µ—Ä–∫–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏
func getUser(w http.ResponseWriter, r *http.Request) {
    currentUser := getCurrentUser(r)
    requestedUserID := r.URL.Query().Get("id")

    if currentUser.ID != requestedUserID && !currentUser.IsAdmin {
        http.Error(w, "Forbidden", http.StatusForbidden)
        return
    }
    // ...
}
```

---

## üîç –ö–∞–∫ —Ä–∞–±–æ—Ç–∞–µ—Ç DAST —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ

### –ê–∫—Ç–∏–≤–Ω–æ–µ —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ

```go
// –ü—Ä–∏–º–µ—Ä –ø—Ä–æ—Å—Ç–æ–≥–æ SQL injection —Ç–µ—Å—Ç–∞
func testSQLInjection(url string, param string) {
    payloads := []string{
        "' OR 1=1--",
        "'; DROP TABLE users--",
        "' UNION SELECT null,null,null--",
    }

    for _, payload := range payloads {
        resp := sendRequest(url + "?" + param + "=" + payload)
        if containsSQLError(resp.Body) {
            reportVulnerability("SQL Injection", url, param)
        }
    }
}
```

### –ü–∞—Å—Å–∏–≤–Ω–æ–µ —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ

```go
// –ê–Ω–∞–ª–∏–∑ –æ—Ç–≤–µ—Ç–æ–≤ –±–µ–∑ –æ—Ç–ø—Ä–∞–≤–∫–∏ –∞—Ç–∞–∫—É—é—â–∏—Ö –∑–∞–ø—Ä–æ—Å–æ–≤
func analyzeResponse(resp *http.Response) {
    body := readBody(resp)

    // –ü–æ–∏—Å–∫ sensitive –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏
    if containsCreditCard(body) {
        reportIssue("Credit card exposed")
    }

    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞–≥–æ–ª–æ–≤–∫–æ–≤ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏
    if resp.Header.Get("X-Frame-Options") == "" {
        reportIssue("Missing X-Frame-Options header")
    }
}
```

### Crawling –∏ fuzzing

```go
// –ü–æ–∏—Å–∫ —Å–∫—Ä—ã—Ç—ã—Ö —ç–Ω–¥–ø–æ–∏–Ω—Ç–æ–≤
func fuzzDirectories(baseURL string) {
    commonDirs := []string{"admin", "api", "backup", "config", "test"}

    for _, dir := range commonDirs {
        url := baseURL + "/" + dir
        resp := sendRequest(url)
        if resp.StatusCode != 404 {
            addToScanQueue(url)
        }
    }
}
```

---

## üõ°Ô∏è –ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å Go –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–π

### 1. **Input Validation**

```go
import (
    "html"
    "net/url"
    "regexp"
)

func sanitizeInput(input string) string {
    // HTML escaping
    escaped := html.EscapeString(input)

    // URL encoding
    encoded := url.QueryEscape(escaped)

    return encoded
}

func validateEmail(email string) bool {
    pattern := `^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`
    matched, _ := regexp.MatchString(pattern, email)
    return matched
}
```

### 2. **Secure HTTP Headers**

```go
func securityMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // CSRF protection
        w.Header().Set("X-Frame-Options", "DENY")
        w.Header().Set("X-Content-Type-Options", "nosniff")
        w.Header().Set("X-XSS-Protection", "1; mode=block")
        w.Header().Set("Strict-Transport-Security", "max-age=31536000")
        w.Header().Set("Content-Security-Policy", "default-src 'self'")

        next.ServeHTTP(w, r)
    })
}
```

### 3. **Rate Limiting**

```go
import "golang.org/x/time/rate"

type RateLimiter struct {
    limiter *rate.Limiter
}

func (rl *RateLimiter) Allow() bool {
    return rl.limiter.Allow()
}

func rateLimitMiddleware(next http.Handler) http.Handler {
    limiter := rate.NewLimiter(10, 100) // 10 requests per second, burst of 100

    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        if !limiter.Allow() {
            http.Error(w, "Rate limit exceeded", http.StatusTooManyRequests)
            return
        }
        next.ServeHTTP(w, r)
    })
}
```

### 4. **Secure Session Management**

```go
import (
    "crypto/rand"
    "encoding/base64"
    "net/http"
    "time"
)

func generateSessionID() string {
    bytes := make([]byte, 32)
    rand.Read(bytes)
    return base64.URLEncoding.EncodeToString(bytes)
}

func setSecureCookie(w http.ResponseWriter, name, value string) {
    cookie := &http.Cookie{
        Name:     name,
        Value:    value,
        HttpOnly: true,  // –ó–∞—â–∏—Ç–∞ –æ—Ç XSS
        Secure:   true,  // –¢–æ–ª—å–∫–æ HTTPS
        SameSite: http.SameSiteStrictMode, // CSRF protection
        MaxAge:   3600,  // 1 —á–∞—Å
    }
    http.SetCookie(w, cookie)
}
```

---

## üåê –°–µ—Ç–µ–≤–∞—è –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å

### TLS/HTTPS –≤ Go

```go
// –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –±–µ–∑–æ–ø–∞—Å–Ω–æ–≥–æ TLS
func createSecureTLSConfig() *tls.Config {
    return &tls.Config{
        MinVersion:   tls.VersionTLS12,
        CipherSuites: []uint16{
            tls.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,
            tls.TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305,
        },
        PreferServerCipherSuites: true,
    }
}

// HTTP –∫–ª–∏–µ–Ω—Ç —Å –ø—Ä–æ–≤–µ—Ä–∫–æ–π —Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç–æ–≤
func createSecureHTTPClient() *http.Client {
    return &http.Client{
        Timeout: 30 * time.Second,
        Transport: &http.Transport{
            TLSClientConfig: &tls.Config{
                InsecureSkipVerify: false, // –í—Å–µ–≥–¥–∞ –ø—Ä–æ–≤–µ—Ä—è–µ–º —Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç—ã
            },
        },
    }
}
```

### –ó–∞—â–∏—Ç–∞ –æ—Ç SSRF

```go
import "net"

func isPrivateIP(ip string) bool {
    private := []string{
        "10.0.0.0/8",
        "172.16.0.0/12",
        "192.168.0.0/16",
        "127.0.0.0/8",
    }

    addr := net.ParseIP(ip)
    for _, block := range private {
        _, subnet, _ := net.ParseCIDR(block)
        if subnet.Contains(addr) {
            return true
        }
    }
    return false
}

func validateURL(targetURL string) error {
    u, err := url.Parse(targetURL)
    if err != nil {
        return err
    }

    ips, err := net.LookupIP(u.Hostname())
    if err != nil {
        return err
    }

    for _, ip := range ips {
        if isPrivateIP(ip.String()) {
            return errors.New("private IP not allowed")
        }
    }
    return nil
}
```

---

## üîê –ö—Ä–∏–ø—Ç–æ–≥—Ä–∞—Ñ–∏—è –≤ Go

### –•–µ—à–∏—Ä–æ–≤–∞–Ω–∏–µ –∏ –ø–æ–¥–ø–∏—Å–∏

```go
import (
    "crypto/hmac"
    "crypto/sha256"
    "encoding/hex"
)

func calculateHMAC(message, secret string) string {
    key := []byte(secret)
    h := hmac.New(sha256.New, key)
    h.Write([]byte(message))
    return hex.EncodeToString(h.Sum(nil))
}

func verifyHMAC(message, messageMAC, secret string) bool {
    expectedMAC := calculateHMAC(message, secret)
    return hmac.Equal([]byte(messageMAC), []byte(expectedMAC))
}
```

### –®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö

```go
import (
    "crypto/aes"
    "crypto/cipher"
    "crypto/rand"
    "io"
)

func encrypt(plaintext []byte, key []byte) ([]byte, error) {
    block, err := aes.NewCipher(key)
    if err != nil {
        return nil, err
    }

    gcm, err := cipher.NewGCM(block)
    if err != nil {
        return nil, err
    }

    nonce := make([]byte, gcm.NonceSize())
    if _, err = io.ReadFull(rand.Reader, nonce); err != nil {
        return nil, err
    }

    ciphertext := gcm.Seal(nonce, nonce, plaintext, nil)
    return ciphertext, nil
}
```

---

## üìù –í–æ–∑–º–æ–∂–Ω—ã–µ –≤–æ–ø—Ä–æ—Å—ã –Ω–∞ —Å–æ–±–µ—Å–µ–¥–æ–≤–∞–Ω–∏–∏

### –°–∫—Ä–∏–Ω–∏–Ω–≥ (–±—ã—Å—Ç—Ä—ã–µ –≤–æ–ø—Ä–æ—Å—ã)

**1. OWASP Top 10:**

- "–ù–∞–∑–æ–≤–∏—Ç–µ —Ç–æ–ø-3 –≤–µ–±-—É—è–∑–≤–∏–º–æ—Å—Ç–∏ –∏–∑ OWASP Top 10"
- "–ß–µ–º –æ—Ç–ª–∏—á–∞–µ—Ç—Å—è SQL injection –æ—Ç XSS?"
- "–ß—Ç–æ —Ç–∞–∫–æ–µ CSRF –∏ –∫–∞–∫ –µ–≥–æ –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—Ç–∏—Ç—å?"

**2. DAST vs –¥—Ä—É–≥–∏–µ –≤–∏–¥—ã —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è:**

- "–í —á–µ–º —Ä–∞–∑–Ω–∏—Ü–∞ –º–µ–∂–¥—É DAST –∏ SAST?"
- "–ö–∞–∫–∏–µ —É—è–∑–≤–∏–º–æ—Å—Ç–∏ –º–æ–∂–µ—Ç –Ω–∞–π—Ç–∏ DAST, –∞ –∫–∞–∫–∏–µ –Ω–µ—Ç?"
- "–ö–æ–≥–¥–∞ –ª—É—á—à–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å DAST, –∞ –∫–æ–≥–¥–∞ penetration testing?"

**3. –ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å Go:**

- "–ö–∞–∫ –±–µ–∑–æ–ø–∞—Å–Ω–æ —Ö—Ä–∞–Ω–∏—Ç—å –ø–∞—Ä–æ–ª–∏ –≤ Go?"
- "–ß—Ç–æ —Ç–∞–∫–æ–µ timing attack –∏ –∫–∞–∫ –µ–≥–æ –∏–∑–±–µ–∂–∞—Ç—å?"
- "–ö–∞–∫ –∑–∞—â–∏—Ç–∏—Ç—å—Å—è –æ—Ç directory traversal –≤ Go?"

### –¢–µ—Ö–Ω–∏—á–µ—Å–∫–æ–µ —Å–æ–±–µ—Å–µ–¥–æ–≤–∞–Ω–∏–µ

**1. –ü—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏–µ –∑–∞–¥–∞—á–∏:**

```go
// –ó–∞–¥–∞—á–∞ 1: –ù–∞–π—Ç–∏ —É—è–∑–≤–∏–º–æ—Å—Ç—å –≤ –∫–æ–¥–µ
func login(w http.ResponseWriter, r *http.Request) {
    username := r.FormValue("username")
    password := r.FormValue("password")

    query := "SELECT id FROM users WHERE username='" + username + "' AND password='" + password + "'"
    rows, _ := db.Query(query)
    // ... —á—Ç–æ –∑–¥–µ—Å—å –Ω–µ —Ç–∞–∫?
}

// –ó–∞–¥–∞—á–∞ 2: –†–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å –±–µ–∑–æ–ø–∞—Å–Ω—É—é –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—é
func secureLogin(w http.ResponseWriter, r *http.Request) {
    // –í–∞—à–∞ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è
}
```

**2. –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–Ω—ã–µ –≤–æ–ø—Ä–æ—Å—ã:**

- "–ö–∞–∫ –±—ã –≤—ã —Å–ø—Ä–æ–µ–∫—Ç–∏—Ä–æ–≤–∞–ª–∏ DAST —Å–∫–∞–Ω–µ—Ä?"
- "–ö–∞–∫–∏–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã –Ω—É–∂–Ω—ã –¥–ª—è –≤–µ–±-—Å–∫–∞–Ω–µ—Ä–∞ —É—è–∑–≤–∏–º–æ—Å—Ç–µ–π?"
- "–ö–∞–∫ –æ–±–µ—Å–ø–µ—á–∏—Ç—å –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å —Å–∞–º–æ–≥–æ —Å–∫–∞–Ω–µ—Ä–∞?"

**3. –°–∏—Å—Ç–µ–º–Ω—ã–µ –≤–æ–ø—Ä–æ—Å—ã:**

- "–ö–∞–∫ –º–æ–Ω–∏—Ç–æ—Ä–∏—Ç—å –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å Go –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è?"
- "–ö–∞–∫–∏–µ –º–µ—Ç—Ä–∏–∫–∏ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏ –≤–∞–∂–Ω–æ –æ—Ç—Å–ª–µ–∂–∏–≤–∞—Ç—å?"
- "–ö–∞–∫ –∏–Ω—Ç–µ–≥—Ä–∏—Ä–æ–≤–∞—Ç—å DAST –≤ CI/CD pipeline?"

---

## üéØ –°–ø–µ—Ü–∏—Ñ–∏—á–Ω—ã–µ –¥–ª—è DAST —Ç–µ–º—ã

### 1. **Web Crawling Security**

```go
// –ë–µ–∑–æ–ø–∞—Å–Ω—ã–π –≤–µ–±-–∫—Ä–∞—É–ª–µ—Ä
type SecureCrawler struct {
    client     *http.Client
    rateLimiter *rate.Limiter
    userAgent   string
}

func (c *SecureCrawler) Crawl(url string) error {
    // –ü—Ä–æ–≤–µ—Ä–∫–∞ URL
    if err := validateURL(url); err != nil {
        return err
    }

    // Rate limiting
    if !c.rateLimiter.Allow() {
        return errors.New("rate limit exceeded")
    }

    // –ë–µ–∑–æ–ø–∞—Å–Ω—ã–π –∑–∞–ø—Ä–æ—Å
    req, _ := http.NewRequest("GET", url, nil)
    req.Header.Set("User-Agent", c.userAgent)

    resp, err := c.client.Do(req)
    // ...
}
```

### 2. **Payload Management**

```go
// –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Ç–µ—Å—Ç–æ–≤—ã–º–∏ payload'–∞–º–∏
type PayloadManager struct {
    sqlInjection []string
    xss          []string
    xxe          []string
}

func (pm *PayloadManager) GetPayloads(vulnType string) []string {
    switch vulnType {
    case "sql":
        return pm.sqlInjection
    case "xss":
        return pm.xss
    case "xxe":
        return pm.xxe
    default:
        return nil
    }
}
```

### 3. **Result Analysis**

```go
// –ê–Ω–∞–ª–∏–∑ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è
type VulnerabilityScanner struct{}

func (vs *VulnerabilityScanner) AnalyzeResponse(resp *http.Response, payload string) *Finding {
    body := readResponseBody(resp)

    // SQL injection detection
    sqlErrors := []string{
        "SQL syntax error",
        "mysql_fetch_array",
        "ORA-01756",
    }

    for _, errorPattern := range sqlErrors {
        if strings.Contains(body, errorPattern) {
            return &Finding{
                Type:     "SQL Injection",
                Severity: "High",
                Payload:  payload,
                Evidence: errorPattern,
            }
        }
    }

    return nil
}
```

---

## üö® Red Flags –≤ –∫–æ–¥–µ

### –ß—Ç–æ –∏—Å–∫–∞—Ç—å –ø—Ä–∏ –∫–æ–¥-—Ä–µ–≤—å—é:

```go
// ‚ùå –ü–ª–æ—Ö–æ
password := r.FormValue("password")
log.Printf("User login attempt: %s with password: %s", username, password)

// ‚úÖ –•–æ—Ä–æ—à–æ
log.Printf("User login attempt: %s", username)

// ‚ùå –ü–ª–æ—Ö–æ
query := "SELECT * FROM users WHERE id = " + userID

// ‚úÖ –•–æ—Ä–æ—à–æ
query := "SELECT * FROM users WHERE id = $1"
rows, err := db.Query(query, userID)

// ‚ùå –ü–ª–æ—Ö–æ
if user.Password == providedPassword {
    // timing attack –≤–æ–∑–º–æ–∂–µ–Ω
}

// ‚úÖ –•–æ—Ä–æ—à–æ
if subtle.ConstantTimeCompare([]byte(user.Password), []byte(providedPassword)) == 1 {
    // –∑–∞—â–∏—Ç–∞ –æ—Ç timing attack
}
```

---

## üìö –†–µ—Å—É—Ä—Å—ã –¥–ª—è –∏–∑—É—á–µ–Ω–∏—è

### –î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è –∏ —Å—Ç–∞–Ω–¥–∞—Ä—Ç—ã:

- **OWASP Testing Guide** - –º–µ—Ç–æ–¥–æ–ª–æ–≥–∏—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
- **NIST Cybersecurity Framework** - —Å—Ç–∞–Ω–¥–∞—Ä—Ç—ã –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏
- **Go Security Guide** - best practices –¥–ª—è Go

### –ò–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã –¥–ª—è –ø—Ä–∞–∫—Ç–∏–∫–∏:

- **DVWA** (Damn Vulnerable Web App) - –¥–ª—è –∏–∑—É—á–µ–Ω–∏—è —É—è–∑–≤–∏–º–æ—Å—Ç–µ–π
- **WebGoat** - OWASP –ø—Ä–æ–µ–∫—Ç –¥–ª—è –æ–±—É—á–µ–Ω–∏—è
- **Burp Suite** - –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞ –≤–µ–±-–ø—Ä–∏–ª–æ–∂–µ–Ω–∏–π

### –ü–æ–ª–µ–∑–Ω—ã–µ Go –ø–∞–∫–µ—Ç—ã:

```go
// –ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å
import "golang.org/x/crypto/bcrypt"
import "golang.org/x/crypto/scrypt"
import "crypto/subtle"

// –í–∞–ª–∏–¥–∞—Ü–∏—è
import "github.com/go-playground/validator/v10"
import "html"
import "net/url"

// Rate limiting
import "golang.org/x/time/rate"
```

---

## üí° –ö–ª—é—á–µ–≤—ã–µ takeaways –¥–ª—è —Å–æ–±–µ—Å–µ–¥–æ–≤–∞–Ω–∏—è

1. **–ó–Ω–∞–π—Ç–µ OWASP Top 10** –Ω–∞–∏–∑—É—Å—Ç—å —Å –ø—Ä–∏–º–µ—Ä–∞–º–∏
2. **–ü–æ–Ω–∏–º–∞–π—Ç–µ —Ä–∞–∑–Ω–∏—Ü—É** –º–µ–∂–¥—É DAST, SAST, IAST
3. **–£–º–µ–π—Ç–µ –Ω–∞—Ö–æ–¥–∏—Ç—å —É—è–∑–≤–∏–º–æ—Å—Ç–∏** –≤ Go –∫–æ–¥–µ
4. **–ó–Ω–∞–π—Ç–µ –∫–∞–∫ –∑–∞—â–∏—â–∞—Ç—å—Å—è** –æ—Ç –æ—Å–Ω–æ–≤–Ω—ã—Ö –∞—Ç–∞–∫
5. **–ü–æ–Ω–∏–º–∞–π—Ç–µ –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—É** –≤–µ–±-—Å–∫–∞–Ω–µ—Ä–æ–≤
6. **–ü—Ä–∞–∫—Ç–∏–∫—É–π—Ç–µ coding** - –±–µ–∑–æ–ø–∞—Å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –Ω–∞ Go

**–ì–ª–∞–≤–Ω–æ–µ:** –ø–æ–∫–∞–∂–∏—Ç–µ, —á—Ç–æ –≤—ã –Ω–µ –ø—Ä–æ—Å—Ç–æ –∑–Ω–∞–µ—Ç–µ —Ç–µ–æ—Ä–∏—é, –Ω–æ –ø–æ–Ω–∏–º–∞–µ—Ç–µ –ø—Ä–∞–∫—Ç–∏—á–µ—Å–∫–æ–µ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏–µ –≤ –∫–æ–Ω—Ç–µ–∫—Å—Ç–µ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏ DAST —Å–∫–∞–Ω–µ—Ä–∞! üéØ
